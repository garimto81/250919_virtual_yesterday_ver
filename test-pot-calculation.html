<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>팟 계산 테스트</title>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background: #1a1a1a; color: white; padding: 20px; }
        .test-case { background: #333; border-radius: 8px; padding: 15px; margin: 20px 0; }
        .test-case h3 { color: #fbbf24; margin: 0 0 10px 0; }
        .actions { background: #222; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .action-line { color: #9ca3af; margin: 5px 0; }
        .result { background: #2d3748; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .expected { color: #10b981; }
        .actual { color: #3b82f6; }
        .error { color: #ef4444; }
        .success { color: #10b981; }
        button { background: #4b5563; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #6b7280; }
    </style>
</head>
<body>
    <h1>🎲 포커 팟 계산 로직 테스트</h1>
    
    <div class="test-case" id="test1">
        <h3>테스트 1: 리버에서 레이즈-폴드 시나리오</h3>
        <div class="scenario">
            <p>초기 팟: 30,000</p>
            <p>Player A: Bet 6,000</p>
            <p>Player B: Raise 26,000</p>
            <p>Player A: Fold</p>
        </div>
        <div class="result">
            <p class="expected">✅ 예상 팟: 36,000 (30,000 + A의 6,000)</p>
            <p class="actual">📊 계산 결과: <span id="result1"></span></p>
        </div>
    </div>
    
    <div class="test-case" id="test2">
        <h3>테스트 2: 멀티웨이 팟 with 폴드</h3>
        <div class="scenario">
            <p>SB: 50 / BB: 100</p>
            <p>Player A (UTG): Raise 300</p>
            <p>Player B (BTN): Call 300</p>
            <p>Player C (SB): Call 300</p>
            <p>Player D (BB): Call 300</p>
            <p>FLOP:</p>
            <p>Player C: Check</p>
            <p>Player D: Bet 600</p>
            <p>Player A: Fold</p>
            <p>Player B: Fold</p>
            <p>Player C: Call 600</p>
        </div>
        <div class="result">
            <p class="expected">✅ 예상 팟: 2,400 (프리플랍 1,200 + 플랍 1,200)</p>
            <p class="actual">📊 계산 결과: <span id="result2"></span></p>
        </div>
    </div>
    
    <div class="test-case" id="test3">
        <h3>테스트 3: 올인 with 언콜 베팅</h3>
        <div class="scenario">
            <p>현재 팟: 1,000</p>
            <p>Player A: Bet 500</p>
            <p>Player B: All-in 3,000</p>
            <p>Player A: Fold</p>
        </div>
        <div class="result">
            <p class="expected">✅ 예상 팟: 1,500 (1,000 + A의 500)</p>
            <p class="expected">✅ 언콜 베팅: 2,500 반환</p>
            <p class="actual">📊 계산 결과: <span id="result3"></span></p>
        </div>
    </div>
    
    <div class="test-case" id="test4">
        <h3>테스트 4: Pot Correction 사용</h3>
        <div class="scenario">
            <p>PREFLOP: 여러 액션으로 팟 500</p>
            <p>FLOP: Pot Correction 1,000</p>
            <p>FLOP: Player A Bet 200</p>
            <p>FLOP: Player B Call 200</p>
        </div>
        <div class="result">
            <p class="expected">✅ 예상 팟: 1,400 (Correction 1,000 + 400)</p>
            <p class="actual">📊 계산 결과: <span id="result4"></span></p>
        </div>
    </div>
    
    <button onclick="runAllTests()">모든 테스트 실행</button>
    <button onclick="location.href='index.html'">메인으로 돌아가기</button>
    
    <script>
        // 테스트용 상태 객체
        function createTestState(scenario) {
            return {
                actionState: scenario.actionState,
                playersInHand: scenario.players,
                playerStatus: scenario.playerStatus || {}
            };
        }
        
        // 포맷팅 함수들
        function unformatNumber(str) {
            if (!str) return '';
            return String(str).replace(/,/g, '');
        }
        
        function formatNumber(num) {
            if (!num && num !== 0) return '';
            return Number(num).toLocaleString('en-US');
        }
        
        // 팟 계산 함수들 (메인 파일에서 복사)
        function calculatePlayerContributions(state) {
            const contributions = {};
            
            ['preflop', 'flop', 'turn', 'river'].forEach(street => {
                const actions = state.actionState[street] || [];
                
                actions.forEach(action => {
                    if(action.amount && action.player && action.action !== 'Pot Correction') {
                        const player = action.player;
                        const amount = parseInt(unformatNumber(action.amount), 10);
                        contributions[player] = (contributions[player] || 0) + amount;
                    }
                });
            });
            
            return contributions;
        }
        
        function calculateUncalledBet(state) {
            const contributions = calculatePlayerContributions(state);
            const activePlayers = state.playersInHand.filter(p => 
                state.playerStatus[p.name] !== 'folded'
            );
            
            if(activePlayers.length === 1) {
                const winner = activePlayers[0];
                const winnerContribution = contributions[winner.name] || 0;
                
                const otherMaxContribution = Math.max(
                    ...Object.entries(contributions)
                        .filter(([player]) => player !== winner.name)
                        .map(([_, amount]) => amount),
                    0
                );
                
                const uncalledAmount = Math.max(0, winnerContribution - otherMaxContribution);
                
                return {
                    amount: uncalledAmount,
                    player: winner.name
                };
            }
            
            return { amount: 0, player: null };
        }
        
        function calculateActualPot(state) {
            let totalPot = 0;
            let potCorrectionFound = false;
            let potCorrectionValue = 0;
            
            // 블라인드와 앤티 추가
            totalPot += parseInt(unformatNumber(state.actionState.smallBlind) || 0, 10);
            totalPot += parseInt(unformatNumber(state.actionState.bigBlind) || 0, 10);
            if(state.actionState.hasBBAnte) {
                totalPot += parseInt(unformatNumber(state.actionState.bigBlind) || 0, 10);
            }
            
            // 모든 스트리트의 액션 합산
            let correctionStreetIndex = -1;
            const streets = ['preflop', 'flop', 'turn', 'river'];
            
            streets.forEach((street, index) => {
                const actions = state.actionState[street] || [];
                
                // Pot Correction 확인
                const potCorrection = actions.find(a => a.action === 'Pot Correction');
                if(potCorrection && correctionStreetIndex === -1) {
                    potCorrectionFound = true;
                    potCorrectionValue = parseInt(unformatNumber(potCorrection.amount), 10);
                    correctionStreetIndex = index;
                    totalPot = potCorrectionValue;
                    
                    // Correction 이후 같은 스트리트의 액션들 추가
                    const correctionIdx = actions.indexOf(potCorrection);
                    for(let i = correctionIdx + 1; i < actions.length; i++) {
                        if(actions[i].amount) {
                            totalPot += parseInt(unformatNumber(actions[i].amount), 10);
                        }
                    }
                } else if(correctionStreetIndex === -1) {
                    // Pot Correction 전까지는 모든 액션 합산
                    actions.forEach(action => {
                        if(action.amount && action.action !== 'Pot Correction') {
                            totalPot += parseInt(unformatNumber(action.amount), 10);
                        }
                    });
                } else if(index > correctionStreetIndex) {
                    // Correction 이후 스트리트의 모든 액션 추가
                    actions.forEach(action => {
                        if(action.amount) {
                            totalPot += parseInt(unformatNumber(action.amount), 10);
                        }
                    });
                }
            });
            
            // 언콜 베팅 제외
            const uncalledBet = calculateUncalledBet(state);
            return totalPot - uncalledBet.amount;
        }
        
        // 테스트 케이스들
        const testCases = {
            test1: {
                actionState: {
                    smallBlind: '0',
                    bigBlind: '0',
                    preflop: [],
                    flop: [],
                    turn: [],
                    river: [
                        { action: 'Pot Correction', amount: '30000' },
                        { player: 'A', action: 'Bets', amount: '6000' },
                        { player: 'B', action: 'Raises', amount: '26000' },
                        { player: 'A', action: 'Folds', amount: null }
                    ]
                },
                players: [
                    { name: 'A' },
                    { name: 'B' }
                ],
                playerStatus: {
                    'A': 'folded',
                    'B': 'active'
                },
                expected: 36000
            },
            test2: {
                actionState: {
                    smallBlind: '50',
                    bigBlind: '100',
                    preflop: [
                        { player: 'A', action: 'Raises', amount: '300' },
                        { player: 'B', action: 'Calls', amount: '300' },
                        { player: 'C', action: 'Calls', amount: '300' },
                        { player: 'D', action: 'Calls', amount: '300' }
                    ],
                    flop: [
                        { player: 'C', action: 'Checks', amount: null },
                        { player: 'D', action: 'Bets', amount: '600' },
                        { player: 'A', action: 'Folds', amount: null },
                        { player: 'B', action: 'Folds', amount: null },
                        { player: 'C', action: 'Calls', amount: '600' }
                    ],
                    turn: [],
                    river: []
                },
                players: [
                    { name: 'A' },
                    { name: 'B' },
                    { name: 'C' },
                    { name: 'D' }
                ],
                playerStatus: {
                    'A': 'folded',
                    'B': 'folded',
                    'C': 'active',
                    'D': 'active'
                },
                expected: 2450  // SB(50) + BB(100) + 4*300 + 2*600
            },
            test3: {
                actionState: {
                    smallBlind: '0',
                    bigBlind: '0',
                    preflop: [],
                    flop: [
                        { action: 'Pot Correction', amount: '1000' },
                        { player: 'A', action: 'Bets', amount: '500' },
                        { player: 'B', action: 'All In', amount: '3000' },
                        { player: 'A', action: 'Folds', amount: null }
                    ],
                    turn: [],
                    river: []
                },
                players: [
                    { name: 'A' },
                    { name: 'B' }
                ],
                playerStatus: {
                    'A': 'folded',
                    'B': 'active'
                },
                expected: 1500  // 1000 + 500 (언콜 2500 제외)
            },
            test4: {
                actionState: {
                    smallBlind: '50',
                    bigBlind: '100',
                    preflop: [
                        { player: 'A', action: 'Raises', amount: '300' },
                        { player: 'B', action: 'Calls', amount: '300' }
                    ],
                    flop: [
                        { action: 'Pot Correction', amount: '1000' },
                        { player: 'A', action: 'Bets', amount: '200' },
                        { player: 'B', action: 'Calls', amount: '200' }
                    ],
                    turn: [],
                    river: []
                },
                players: [
                    { name: 'A' },
                    { name: 'B' }
                ],
                playerStatus: {
                    'A': 'active',
                    'B': 'active'
                },
                expected: 1400  // Correction 1000 + 400
            }
        };
        
        function runTest(testId) {
            const test = testCases[testId];
            const state = createTestState(test);
            const result = calculateActualPot(state);
            
            const resultElement = document.getElementById(`result${testId.slice(-1)}`);
            if(result === test.expected) {
                resultElement.innerHTML = `<span class="success">${formatNumber(result)} ✅ 정답!</span>`;
            } else {
                resultElement.innerHTML = `<span class="error">${formatNumber(result)} ❌ (예상: ${formatNumber(test.expected)})</span>`;
            }
            
            // 언콜 베팅이 있는 경우 표시
            if(testId === 'test3') {
                const uncalled = calculateUncalledBet(state);
                resultElement.innerHTML += `<br>언콜 베팅: ${formatNumber(uncalled.amount)}`;
            }
        }
        
        function runAllTests() {
            Object.keys(testCases).forEach(testId => {
                runTest(testId);
            });
        }
        
        // 페이지 로드 시 자동 실행
        window.onload = runAllTests;
    </script>
</body>
</html>