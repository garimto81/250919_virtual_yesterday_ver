<!DOCTYPE html>
<!--
  ============================================
  포커 핸드 로거 (Poker Hand Logger)
  Version: 2.0.0
  Last Modified: 2025-01-02 10:30 KST
  
  Change Log:
  - v2.0.0 (2025-01-02): Smart Check/Call 버튼 및 스트리트 자동 진행 시스템 구현
  - v1.9.0 (2024-12-30): 팟 사이즈 조정 로직 및 올인 콜 버그 수정
  - v1.8.0 (2024-12-28): 플레이어 상태 추적 시스템 추가
  ============================================
-->
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <title>포커 핸드 로거 v2.8.1</title>
  <script src="https://cdn-tailwindcss.vercel.app/"></script>
  <script src="chip-analysis-module.js" defer></script>
  <!-- 테이블 관리 모듈 v59 - IN/OUT 두 가지 상태만 사용 -->
  <script src="table-management-v59.js" defer></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@700&family=Noto+Sans+KR:wght@400;500;700&display=swap');
    html, body { height: 100vh; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    #app-container { display: flex; flex-direction: column; height: 100%; }
    main { flex-grow: 1; overflow-y: auto; }
    .btn { transition: all 0.1s ease-in-out; }
    .btn:active { transform: scale(0.95); }
    .btn-selected { background-color: #FBBF24 !important; color: #111827 !important; font-weight: bold; }
    .card-placeholder { border: 2px dashed #4B5563; cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 1px; background-color: rgba(255,255,255,0.05); flex-shrink: 0; }
    .card-display { font-family: 'Roboto', sans-serif; background-color: white; border-radius: 4px; padding: 1px; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.8rem; }
    .card-display .rank { font-weight: bold; font-size: 1rem; }
    .modal { transition: opacity 0.3s ease; backdrop-filter: blur(4px); }
    .card-selector-btn { font-family: 'Roboto', sans-serif; font-size: 1rem; font-weight: bold; }
    .card-selector-btn.card-red { color: #DC2626; }
    .card-selector-btn.card-black { color: #111827; }
    .card-selector-btn.selected { border: 3px solid #FBBF24; transform: scale(0.95); }
    .player-card.is-winner { background-color: rgba(251, 191, 36, 0.1); }
    select, input[type="text"] { font-size: 0.875rem; }
    .chip-color-sample { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #4B5563; cursor: pointer; }
    .chip-analysis-btn { font-size: 0.75rem; padding: 0.25rem 0.5rem; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .pulse-animation { animation: pulse 2s infinite; }
  </style>
</head>
<body class="bg-gray-900 text-white antialiased">
  <div id="app-container">
    <!-- 버전 표시 헤더 -->
    <div class="bg-gray-900 border-b border-gray-700 px-3 py-1">
      <div class="flex justify-between items-center text-xs">
        <span class="font-bold text-amber-400">포커 핸드 로거</span>
        <span id="version-display" class="text-gray-400">v2.8.1</span>
      </div>
    </div>
    <main class="p-2 space-y-2">
      <div class="bg-gray-800 p-2 rounded-lg space-y-2">
        <div class="flex items-center gap-2 text-sm">
          <div class="flex-1 flex items-center gap-1 bg-gray-700 p-1 rounded-md min-w-0">
            <span id="hand-number-display" class="font-bold px-1 whitespace-nowrap">#--</span>
            <button id="load-hand-btn" class="btn bg-gray-600 px-2 py-1 rounded-md text-xs">Load</button>
            <label class="flex items-center gap-1 text-xs ml-2">
              <input type="checkbox" id="smart-mode-toggle" checked class="h-3 w-3">
              <span>Smart</span>
            </label>
          </div>
          <div class="flex-1 min-w-0">
            <button id="table-selector-btn" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1 text-left flex items-center justify-between hover:bg-gray-600">
              <span id="selected-table-display">테이블 선택</span>
              <span class="text-gray-400">▼</span>
            </button>
          </div>
          <div class="flex-1 flex items-center gap-1 min-w-0">
            <select id="timezone-selector" class="flex-grow bg-gray-700 border border-gray-600 rounded-md px-2 py-1 text-xs"></select>
            <span id="time-display" class="bg-gray-900/50 p-1 rounded-md font-mono text-xs"></span>
          </div>
          <div class="flex items-center gap-1">
            <button id="manage-players-btn" class="btn bg-gray-600 p-1 rounded-md text-xs">관리</button>
            <button id="refresh-data" class="text-lg" title="데이터 새로고침">🔄</button>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <div class="text-xs text-gray-300 flex items-center gap-2">
            <button id="cam-btn-1" class="btn bg-gray-700 px-2 py-1 rounded"></button>
            <button id="cam-btn-2" class="btn bg-gray-700 px-2 py-1 rounded"></button>
          </div>
          <div class="text-right text-xs text-gray-400">
            <span id="data-stamp"></span>
          </div>
        </div>
        <div id="player-selection-buttons" class="flex flex-wrap gap-1"></div>
      </div>

      <div id="player-details-section" class="bg-gray-800 p-2 rounded-lg space-y-1"></div>

      <div class="bg-gray-800 p-2 rounded-lg space-y-2">
        <div class="flex flex-wrap items-center gap-2">
          <div class="flex items-center gap-1">
            <div class="input-with-keypad flex items-center">
              <input type="text" id="small-blind-input" class="number-input w-12 bg-gray-700 p-1 rounded-md text-sm" placeholder="SB">
              <button class="keypad-icon-btn btn bg-gray-600 p-1 rounded-md text-xs h-auto w-auto px-2 py-1">⌨️</button>
            </div>
            <div class="input-with-keypad flex items-center">
              <input type="text" id="big-blind-input" class="number-input w-12 bg-gray-700 p-1 rounded-md text-sm" placeholder="BB">
              <button class="keypad-icon-btn btn bg-gray-600 p-1 rounded-md text-xs h-auto w-auto px-2 py-1">⌨️</button>
            </div>
            <div class="flex items-center">
              <input id="bb-ante-checkbox" type="checkbox" class="h-4 w-4 bg-gray-700 border-gray-600 rounded text-amber-500">
              <label for="bb-ante-checkbox" class="ml-1 text-xs">Ante</label>
            </div>
          </div>
          <div id="board-card-placeholders" class="flex flex-wrap gap-1 items-center flex-grow justify-end"></div>
        </div>
        <div class="space-y-1" id="street-logs-container"></div>
      </div>


      <div class="bg-gray-800 p-2 rounded-lg space-y-2">
        <div class="flex flex-wrap gap-1 items-center">
          <span class="text-sm font-bold mr-2">승자:</span>
          <div id="winner-buttons" class="flex flex-wrap gap-1 flex-grow"></div>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <button id="reset-btn" class="w-full btn bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-md text-sm">새 핸드</button>
          <button id="send-to-sheet-btn" class="w-full btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md text-sm">시트 전송</button>
        </div>
        <p id="feedback-message" class="text-center h-4 text-xs font-semibold"></p>
      </div>

    </main>
    <footer class="flex-shrink-0 p-1 text-center">
      <button id="show-log-btn" class="text-gray-500 hover:text-gray-300 text-xs">로그 보기</button>
    </footer>
  </div>

  <!-- Modals -->
  <div id="card-selector-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-2 z-50 hidden opacity-0"></div>
  <div id="action-pad-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0"></div>
  <div id="keypad-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0"></div>
  <div id="load-hand-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0"></div>
  <!-- 플레이어 & 칩 관리 모달 -->
  <div id="registration-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0">
    <div class="bg-gray-800 rounded-lg p-4 max-w-lg w-full max-h-[90vh] overflow-y-auto">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold text-amber-400">설정 관리</h2>
        <button id="close-registration-modal" class="text-2xl hover:text-gray-400">&times;</button>
      </div>
      
      <!-- 탭 메뉴 -->
      <div class="flex gap-2 mb-4">
        <button id="tab-players" class="tab-btn bg-amber-600 text-white px-4 py-2 rounded-lg font-medium">플레이어</button>
        <button id="tab-chips" class="tab-btn bg-gray-600 hover:bg-gray-500 text-white px-4 py-2 rounded-lg font-medium">칩 컬러</button>
      </div>
      
      <!-- 플레이어 관리 탭 -->
      <div id="tab-content-players" class="tab-content">
        <h3 class="text-lg font-bold mb-3">플레이어 관리</h3>
        <div id="player-management-content" class="space-y-2">
          <!-- 플레이어 관리 내용이 여기 표시됨 -->
          <p class="text-gray-400 text-sm">플레이어 선택 후 정보를 수정할 수 있습니다.</p>
        </div>
      </div>
      
      <!-- 칩 컬러 관리 탭 -->
      <div id="tab-content-chips" class="tab-content hidden">
        <h3 class="text-lg font-bold mb-3">칩 컬러 등록</h3>
        <div class="space-y-3">
          <div class="flex justify-between items-center">
            <span class="text-sm text-gray-400">최대 5개까지 등록 가능</span>
            <button id="add-chip-color-btn" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm">+ 칩 추가</button>
          </div>
          <div id="chip-colors-container" class="flex gap-2 flex-wrap">
            <!-- 칩 컬러들이 여기 표시됨 -->
          </div>
          <div id="chip-values-list" class="space-y-2 mt-3">
            <!-- 칩 값 입력 필드들이 여기 표시됨 -->
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="log-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0">
    <div class="bg-gray-800 rounded-lg p-4 w-full max-w-lg h-2/3 flex flex-col">
      <div class="flex justify-between items-center mb-2">
        <h2 class="text-xl font-bold text-amber-400">로딩 로그</h2>
        <button id="close-log-modal" class="text-2xl">&times;</button>
      </div>
      <div id="log-display" class="bg-gray-900/50 p-3 rounded-md flex-grow overflow-y-auto text-sm font-mono"></div>
    </div>
  </div>

  <!-- 칩 컬러 선택 모달 (카메라 또는 파일) -->
  <div id="chip-color-modal" class="modal fixed inset-0 bg-black bg-opacity-75 hidden z-50">
    <div class="flex items-center justify-center h-full p-4">
      <div class="bg-gray-800 rounded-lg p-4 max-w-md w-full">
        <h3 class="text-lg font-bold mb-3 text-amber-400">칩 등록</h3>
        
        <!-- 선택 옵션 -->
        <div id="chip-option-select" class="mb-4">
          <p class="text-sm text-gray-300 mb-3">칩 사진을 추가하는 방법을 선택하세요:</p>
          <div class="grid grid-cols-2 gap-2">
            <button id="select-camera-btn" class="bg-blue-600 hover:bg-blue-700 p-3 rounded-lg flex flex-col items-center">
              <span class="text-2xl mb-1">📷</span>
              <span class="text-sm">사진 촬영</span>
            </button>
            <button id="select-file-btn" class="bg-purple-600 hover:bg-purple-700 p-3 rounded-lg flex flex-col items-center">
              <span class="text-2xl mb-1">📁</span>
              <span class="text-sm">파일 선택</span>
            </button>
          </div>
        </div>
        
        <!-- 카메라 뷰 (숨김 상태) -->
        <div id="camera-view" class="hidden">
          <video id="chip-video" class="w-full rounded-lg mb-3" autoplay playsinline></video>
          <canvas id="chip-canvas" class="hidden"></canvas>
        </div>
        
        <!-- 이미지 프리뷰 (숨김 상태) -->
        <div id="image-preview" class="hidden">
          <img id="preview-img" class="w-full rounded-lg mb-3" alt="미리보기">
        </div>
        
        <!-- 파일 입력 (숨김) -->
        <input type="file" id="file-input" class="hidden" accept="image/*">
        
        <!-- 칩 값 입력 -->
        <input type="text" id="chip-value-input" class="w-full bg-gray-700 px-3 py-2 rounded mb-3" placeholder="칩 값 (예: 1000)">
        
        <!-- 액션 버튼들 -->
        <div class="flex gap-2">
          <button id="capture-chip-btn" class="flex-1 bg-green-600 hover:bg-green-700 py-2 rounded-lg font-medium hidden">촬영</button>
          <button id="confirm-chip-btn" class="flex-1 bg-green-600 hover:bg-green-700 py-2 rounded-lg font-medium hidden">확인</button>
          <button id="retry-chip-btn" class="flex-1 bg-yellow-600 hover:bg-yellow-700 py-2 rounded-lg font-medium hidden">다시선택</button>
          <button id="close-chip-modal" class="flex-1 bg-gray-600 hover:bg-gray-700 py-2 rounded-lg font-medium">취소</button>
        </div>
        
        <!-- 안내 메시지 -->
        <div id="chip-info-message" class="mt-3 text-xs text-gray-400 text-center">
          💡 PC에서는 파일 선택, 모바일에서는 카메라 촬영을 권장합니다
        </div>
      </div>
    </div>
  </div>

  <!-- 칩 스택 분석 모달 -->
  <div id="stack-analysis-modal" class="modal fixed inset-0 bg-black bg-opacity-75 hidden z-50">
    <div class="flex items-center justify-center h-full p-4">
      <div class="bg-gray-800 rounded-lg p-4 max-w-lg w-full max-h-[90vh] overflow-y-auto">
        <h3 class="text-lg font-bold mb-3 text-amber-400">
          <span id="analyzing-player-name">플레이어</span> 칩 스택 분석
        </h3>
        <div id="stack-images-container" class="grid grid-cols-2 gap-2 mb-3"></div>
        <video id="stack-video" class="w-full rounded-lg mb-3" autoplay playsinline></video>
        <canvas id="stack-canvas" class="hidden"></canvas>
        <div class="flex gap-2 mb-3">
          <button id="capture-stack-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 py-2 rounded-lg font-medium">사진 추가</button>
          <button id="analyze-stack-btn" class="flex-1 bg-green-600 hover:bg-green-700 py-2 rounded-lg font-medium" disabled>AI 분석</button>
        </div>
        <button id="close-stack-modal" class="w-full bg-gray-600 hover:bg-gray-700 py-2 rounded-lg font-medium">닫기</button>
      </div>
    </div>
  </div>

  <!-- AI 분석 중 오버레이 -->
  <div id="analyzing-overlay" class="fixed inset-0 bg-black bg-opacity-80 hidden z-[60]">
    <div class="flex items-center justify-center h-full">
      <div class="bg-gray-900 rounded-lg p-6 text-center">
        <div class="text-3xl mb-3 pulse-animation">🤖</div>
        <p class="text-lg font-medium mb-2">AI 분석 중...</p>
        <p class="text-sm text-gray-400">칩 스택을 분석하고 있습니다</p>
      </div>
    </div>
  </div>

  <!-- 테이블 선택 모달 -->
  <div id="table-selector-modal" class="modal fixed inset-0 bg-black bg-opacity-75 hidden z-50">
    <div class="flex items-center justify-center h-full p-2">
      <div class="bg-gray-800 rounded-lg w-full max-w-md h-full max-h-screen flex flex-col">
        <!-- 헤더 -->
        <div class="flex items-center justify-between p-4 border-b border-gray-700">
          <h3 class="text-lg font-bold text-amber-400">🎯 테이블 선택</h3>
          <button id="close-table-selector" class="text-gray-400 hover:text-white text-xl">×</button>
        </div>
        
        <!-- 검색 및 필터 -->
        <div class="p-4 border-b border-gray-700">
          <input type="text" id="table-search" placeholder="테이블 번호 또는 플레이어 검색..." 
                 class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-sm mb-3">
          <div class="flex gap-2 flex-wrap">
            <button id="filter-all" class="filter-btn px-3 py-1 rounded-full text-xs bg-blue-600 text-white">전체</button>
            <button id="filter-active" class="filter-btn px-3 py-1 rounded-full text-xs bg-gray-600 hover:bg-gray-500">활성</button>
            <button id="filter-empty" class="filter-btn px-3 py-1 rounded-full text-xs bg-gray-600 hover:bg-gray-500">빈테이블</button>
          </div>
        </div>
        
        <!-- 페이지 토글 -->
        <div class="px-4 py-2 border-b border-gray-700">
          <div class="flex items-center justify-between">
            <button id="prev-page" class="px-3 py-1 bg-gray-600 rounded hover:bg-gray-500 disabled:opacity-50">◀</button>
            <span id="page-info" class="text-sm text-gray-400">1-20 / 100</span>
            <button id="next-page" class="px-3 py-1 bg-gray-600 rounded hover:bg-gray-500 disabled:opacity-50">▶</button>
          </div>
        </div>
        
        <!-- 테이블 그리드 -->
        <div class="flex-1 overflow-y-auto p-4">
          <div id="table-grid" class="grid grid-cols-4 gap-2">
            <!-- 테이블 버튼들이 여기에 동적 생성됩니다 -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  /**
   * ============================================
   * 포커 핸드 로거 - Main JavaScript
   * Version: 2.2.0
   * Last Modified: 2025-09-08 KST
   * Changes: 
   * - v2.8.0: 올인 제한 고려한 정확한 팔 계산 로직 구현
   * - v2.7.0: 팔 계산 로직 개선 - 블라인드/안티를 플레이어별 기여액에 포함
   * - v2.6.1: getElements is not defined 오류 수정 - getCamNumber 함수 내 전역 el 객체 사용
   * - v2.6.0: 스마트폰 최적화 테이블 선택 UI - 버튼식 페이지 토글 방식
   * - v2.5.1: 카메라 번호 초기값 로직 개선 - 표시된 값으로 자동 입력
   * - v2.5.0: IN/OUT 테이블 관리 시스템 및 console 오류 해결
   * - v2.4.0: 카메라 번호 로딩 개선 및 Type 시트 칩 업데이트 수정
   * - v2.2.0: AI 기반 칩 스택 분석 기능 추가 (Gemini API)
   * - v2.1.1: Pot Correction 로직 개선 - 정확한 팟 설정
   * Author: garimto81 with Claude
   * ============================================
   */
  
  // 버전 정보 전역 상수
  const APP_VERSION = 'v2.8.2';
  const VERSION_DATE = '2025-01-10';
  const VERSION_INFO = `포커 핸드 로거 ${APP_VERSION} (${VERSION_DATE})`;
  
  // Gemini API 설정
  const GEMINI_API_KEY = 'AIzaSyBB8uqP1ECTe40jknSy5XK71TCs8_KbGV0';
  const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
  
  // 버전 정보를 항상 콘솔에 표시
  console.log(`%c====================================`, 'color: #fbbf24');
  console.log(`%c🎯 ${VERSION_INFO}`, 'color: #fbbf24; font-size: 18px; font-weight: bold');
  console.log(`%c====================================`, 'color: #fbbf24');
  console.log('%c📱 AI 칩 스택 분석 기능 활성화', 'color: #10b981');
  console.log('%c💡 관리 버튼 → 칩 컬러 탭에서 칩 등록', 'color: #60a5fa');
  
  // 모든 에러와 경고에 버전 정보 포함
  const originalError = console.error;
  const originalWarn = console.warn;
  console.error = function(...args) {
    originalError.apply(console, [`[${APP_VERSION}]`, ...args]);
  };
  console.warn = function(...args) {
    originalWarn.apply(console, [`[${APP_VERSION}]`, ...args]);
  };
  
  document.addEventListener('DOMContentLoaded', () => {
    console.log(`%c🚀 앱 초기화 시작 - ${VERSION_INFO}`, 'color: #10b981; font-weight: bold');
    console.log('Initialized at', new Date().toISOString());
    
    // 칩 분석 모듈 초기화는 state 객체 생성 후에 진행
    
    // 화면에 버전 표시 업데이트
    const versionDisplay = document.getElementById('version-display');
    if(versionDisplay) {
      versionDisplay.textContent = `${APP_VERSION} (${VERSION_DATE})`;
    }
    
    // ====== CONFIG (필수: 실제 URL로 교체) ======
    const CSV_HAND_URL  = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSDY_i4330JANAjIz4sMncdJdRHsOkfUCjQusHTGQk2tykrhA4d09LeIp3XRbLd8hkN6SgSB47k_nux/pub?gid=1906746276&single=true&output=csv"; // Hand 탭 CSV
    const CSV_INDEX_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSDY_i4330JANAjIz4sMncdJdRHsOkfUCjQusHTGQk2tykrhA4d09LeIp3XRbLd8hkN6SgSB47k_nux/pub?gid=1354012271&single=true&output=csv"; // Index 탭 CSV (HandIndex 대신 Index 사용)
    const CSV_TYPE_URL  = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSDY_i4330JANAjIz4sMncdJdRHsOkfUCjQusHTGQk2tykrhA4d09LeIp3XRbLd8hkN6SgSB47k_nux/pub?gid=998576925&single=true&output=csv";
    // Apps Script URL - 재배포 후 새 URL로 교체 필요
    const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzbya-VriY5oEDOEO4W80VJz4GaY6QhBb38-3JvSrwl5Qo-7K8D0jqbjTO06bO6VAYj/exec";
    // 전역 변수로도 설정 (테이블 관리 모듈용)
    window.APPS_SCRIPT_URL = APPS_SCRIPT_URL;

    // ====== STATE ======
    let timeUpdater;
    window.state = {
      currentStreet: 'preflop',  // 현재 진행 중인 스트리트
      camNumbers: { cam1no:'', cam2no:'' }, // 파일 넘버 입력이 있다면 여기에 저장
      lastCamNo: null,        // 마지막 입력 추적(연속 증가 기본값 제공용)

      playerDataByTable: {},     // { [table]: [{name, chips, notable}] }
      camPreset: { cam1:'', cam2:'' }, // Type!A2/A3
      allTables: [],
      indexRows: [],             // [{handNumber, handUpdatedAt, table, ...}]
      allHandNumbers: [],        // latest numbers (from Index)
      handCsvCache: null,        // raw rows for on-demand hand parsing
      allHandData: {},           // { [handNumber]: parsed hand block (latest) }
      selectedTable: null,
      playersInHand: [],
      board: [],
      playerStatus: {},          // { playerName: 'active' | 'folded' | 'allin' }
      smartCheckCall: true,      // 스마트 Check/Call 버튼 사용
      actionState: {
        handNumber: '',
        smallBlind: '', bigBlind: '', hasBBAnte: false,
        preflop: [], flop: [], turn: [], river: [],
      },
      modalState: {
        cardTarget: null,
        actionPadStreet: null, actionPadPlayer: null, actionPadCurrentAction: null,
        keypadTarget: null, keypadOptions: {},
      },
      selectedTimezone: 'Asia/Seoul',
      // 칩 분석 관련 상태
      chipColors: [], // [{color: '#fff', value: 1000, image: 'base64...'}]
      maxChips: 5,
      currentChipSlot: null,
      playerStacks: {}, // {playerName: {images: [], estimatedStack: 0, analysis: ''}}
      currentAnalyzingPlayer: null,
      stackImages: [] // 현재 촬영 중인 스택 이미지들
    };

    // 칩 분석 모듈 초기화 (state 객체 생성 후)
    if (typeof initChipAnalyzer === 'function') {
      setTimeout(() => {
        initChipAnalyzer();
        console.log('✅ AI 칩 분석 모듈 활성화');
      }, 100);
    }

    // ====== CONSTS ======
    const SUITS = { s:'♠', h:'♥', d:'♦', c:'♣' };
    const RANKS = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'];

    // ====== EL ======
    const el = {
      refreshDataBtn: document.getElementById('refresh-data'),
      tableSelectorBtn: document.getElementById('table-selector-btn'),
      selectedTableDisplay: document.getElementById('selected-table-display'),
      tableSelectorModal: document.getElementById('table-selector-modal'),
      playerSelectionButtons: document.getElementById('player-selection-buttons'),
      boardCardPlaceholders: document.getElementById('board-card-placeholders'),
      playerDetailsSection: document.getElementById('player-details-section'),
      handNumberDisplay: document.getElementById('hand-number-display'),
      loadHandBtn: document.getElementById('load-hand-btn'),
      smallBlindInput: document.getElementById('small-blind-input'),
      bigBlindInput: document.getElementById('big-blind-input'),
      bbAnteCheckbox: document.getElementById('bb-ante-checkbox'),
      streetLogsContainer: document.getElementById('street-logs-container'),
      winnerButtons: document.getElementById('winner-buttons'),
      sendToSheetBtn: document.getElementById('send-to-sheet-btn'),
      resetBtn: document.getElementById('reset-btn'),
      feedbackMessage: document.getElementById('feedback-message'),
      logDisplay: document.getElementById('log-display'),
      logModal: document.getElementById('log-modal'),
      showLogBtn: document.getElementById('show-log-btn'),
      closeLogModalBtn: document.getElementById('close-log-modal'),
      cardSelectorModal: document.getElementById('card-selector-modal'),
      actionPadModal: document.getElementById('action-pad-modal'),
      keypadModal: document.getElementById('keypad-modal'),
      loadHandModal: document.getElementById('load-hand-modal'),
      timezoneSelector: document.getElementById('timezone-selector'),
      timeDisplay: document.getElementById('time-display'),
      managePlayersBtn: document.getElementById('manage-players-btn'),
      registrationModal: document.getElementById('registration-modal'),
      cam1: document.getElementById('cam-btn-1'),
      cam2: document.getElementById('cam-btn-2'),
      dataStamp: document.getElementById('data-stamp'),
    };

    // ====== LOG MODAL ======
    function openLogModal(){ 
      el.logModal.classList.remove('hidden'); 
      setTimeout(()=>el.logModal.classList.remove('opacity-0'),10);
    }
    function closeLogModal(){ el.logModal.classList.add('opacity-0'); setTimeout(()=>el.logModal.classList.add('hidden'),300); }
    function logMessage(msg,isError=false){
      const d=document.createElement('div');
      d.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`;
      d.className=isError?'text-red-400':'text-green-400';
      el.logDisplay.appendChild(d); el.logDisplay.scrollTop=el.logDisplay.scrollHeight;
    }

    // ====== TIME/TZ ======
    function getFormattedTimeInTimezone(date, tz){
      try{
        return new Intl.DateTimeFormat('ko-KR',{timeZone:tz,hour12:false,hour:'2-digit',minute:'2-digit',second:'2-digit'}).format(date);
      }catch(_){
        const pad=n=>String(n).padStart(2,'0');
        return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
      }
    }
    function populateTimezones(){
      const tzs={ "Asia/Seoul":"한국(KST)", "Asia/Nicosia":"키프로스(EET)" };
      const s=el.timezoneSelector; s.innerHTML='';
      for(const [v,t] of Object.entries(tzs)){
        const opt=document.createElement('option'); opt.value=v; opt.textContent=t; s.appendChild(opt);
      }
      s.value=window.state.selectedTimezone;
    }
    function updateTimeDisplay(){ el.timeDisplay.textContent=getFormattedTimeInTimezone(new Date(),window.state.selectedTimezone); }

    // ====== UTILS ======
    const formatNumber = (val) => val ? new Intl.NumberFormat('en-US').format(String(val).replace(/,/g,'')) : '';
    const unformatNumber = (val) => String(val || '').replace(/,/g, '');
    const toCamelCase = (s) => s.replace(/-([a-z])/g, g => g[1].toUpperCase());
    const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
    const pad4 = n => String(Math.max(0, parseInt(String(n||'0').replace(/\D/g,''),10)||0)).padStart(4, '0');

    // Robust CSV parse (handles quotes)
    function parseCSV(text){
      const rows=[]; let i=0, field='', inQ=false, row=[];
      while(i<text.length){
        const c=text[i];
        if(inQ){
          if(c==='"'){
            if(text[i+1]==='"'){ field+='"'; i++; } else inQ=false;
          }else field+=c;
        }else{
          if(c===','){ row.push(field); field=''; }
          else if(c==='\n'){ row.push(field); rows.push(row); row=[]; field=''; }
          else if(c==='"'){ inQ=true; }
          else if(c!=='\r'){ field+=c; }
        }
        i++;
      }
      if(field!==''||row.length) { row.push(field); rows.push(row); }
      return rows;
    }

    function formatCardDisplay(cardId){
      const rank=cardId.slice(0,-1), suitKey=cardId.slice(-1);
      const colorClass=(suitKey==='h'||suitKey==='d')?'text-red-500':'text-black';
      return `<div class="card-display h-full w-full ${colorClass}"><div class="rank">${rank}</div><div>${SUITS[suitKey]}</div></div>`;
    }

    // ====== RENDERERS ======
    function renderTableSelection(){
      // 더이상 필요하지 않지만 호환성을 위해 유지
      updateSelectedTableDisplay();
    }

    // ====== 새로운 테이블 선택 시스템 ======
    let tableModalState = {
      currentPage: 1,
      tablesPerPage: 20,
      currentFilter: 'all',
      searchTerm: ''
    };

    function updateSelectedTableDisplay() {
      const display = el.selectedTableDisplay;
      if (window.state.selectedTable) {
        const playerCount = (window.state.playerDataByTable[window.state.selectedTable] || []).length;
        display.textContent = `${window.state.selectedTable} (${playerCount}명)`;
      } else {
        display.textContent = '테이블 선택';
      }
    }

    function getFilteredTables() {
      let tables = window.state.allTables;
      
      // 검색 필터
      if (tableModalState.searchTerm) {
        const term = tableModalState.searchTerm.toLowerCase();
        tables = tables.filter(table => {
          // 테이블 이름 매치
          if (table.toLowerCase().includes(term)) return true;
          // 플레이어 이름 매치
          const players = window.state.playerDataByTable[table] || [];
          return players.some(p => p.name.toLowerCase().includes(term));
        });
      }
      
      // 상태 필터
      if (tableModalState.currentFilter === 'active') {
        tables = tables.filter(table => {
          const players = window.state.playerDataByTable[table] || [];
          return players.length > 0;
        });
      } else if (tableModalState.currentFilter === 'empty') {
        tables = tables.filter(table => {
          const players = window.state.playerDataByTable[table] || [];
          return players.length === 0;
        });
      }
      
      return tables;
    }

    function renderTableGrid() {
      const filteredTables = getFilteredTables();
      const startIdx = (tableModalState.currentPage - 1) * tableModalState.tablesPerPage;
      const endIdx = startIdx + tableModalState.tablesPerPage;
      const pageTables = filteredTables.slice(startIdx, endIdx);
      
      const grid = document.getElementById('table-grid');
      grid.innerHTML = '';
      
      pageTables.forEach(table => {
        const players = window.state.playerDataByTable[table] || [];
        const playerCount = players.length;
        const isSelected = window.state.selectedTable === table;
        
        // 상태별 색상
        let statusColor = 'bg-gray-600'; // 빈 테이블
        if (playerCount >= 7) statusColor = 'bg-green-600'; // 활성
        else if (playerCount >= 4) statusColor = 'bg-yellow-600'; // 보통
        else if (playerCount >= 1) statusColor = 'bg-blue-600'; // 적음
        
        const button = document.createElement('button');
        button.className = `table-btn ${statusColor} hover:brightness-110 p-3 rounded-lg text-white text-sm font-medium relative transition-all ${isSelected ? 'ring-2 ring-amber-400' : ''}`;
        button.innerHTML = `
          <div class="text-xs font-bold">${table}</div>
          <div class="text-xs opacity-75">${playerCount}명</div>
          ${isSelected ? '<div class="absolute top-1 right-1 text-amber-400">●</div>' : ''}
        `;
        
        button.onclick = () => {
          window.state.selectedTable = table;
          window.state.playersInHand = [];
          updateSelectedTableDisplay();
          closeTableSelectorModal();
          renderAll();
        };
        
        grid.appendChild(button);
      });
      
      // 페이지 정보 업데이트
      const totalPages = Math.ceil(filteredTables.length / tableModalState.tablesPerPage);
      const pageInfo = document.getElementById('page-info');
      const startNum = startIdx + 1;
      const endNum = Math.min(endIdx, filteredTables.length);
      pageInfo.textContent = `${startNum}-${endNum} / ${filteredTables.length}`;
      
      // 페이지 버튼 상태
      document.getElementById('prev-page').disabled = tableModalState.currentPage === 1;
      document.getElementById('next-page').disabled = tableModalState.currentPage >= totalPages;
    }

    function openTableSelectorModal() {
      el.tableSelectorModal.classList.remove('hidden');
      renderTableGrid();
      document.getElementById('table-search').focus();
    }

    function closeTableSelectorModal() {
      el.tableSelectorModal.classList.add('hidden');
      tableModalState.searchTerm = '';
      document.getElementById('table-search').value = '';
    }
    function renderPlayerSelection(){
      if(!window.state.selectedTable){
        el.playerSelectionButtons.innerHTML='<p class="text-gray-500 text-xs">테이블을 먼저 선택해주세요.</p>';
        return;
      }
      const arr=window.state.playerDataByTable[window.state.selectedTable]||[];
      el.playerSelectionButtons.innerHTML = arr.map(p=>{
        const sel=window.state.playersInHand.some(pp=>pp.name===p.name);
        const notable = p.notable ? '⭐' : '';
        return `<button class="btn ${sel?'btn-selected':'bg-gray-600 hover:bg-gray-500'} px-2 py-1 text-xs rounded-md" data-player-name="${p.name}">${notable}${p.name}</button>`;
      }).join('');
    }
    function renderPlayerDetails(){
      const finalPot = calculateFinalPot();
      
      el.playerDetailsSection.innerHTML = window.state.playersInHand.map(p=>{
        const roleClass=(p.role==='winner')?'is-winner':'';
        const winnerBadge = p.role === 'winner' && finalPot > 0 ? 
          `<span class="ml-2 text-amber-300 font-bold text-xs animate-pulse">🏆 +${formatNumber(finalPot)}</span>` : '';
        
        return `<div class="player-card flex items-center gap-2 text-sm border-b border-gray-700 pb-1 ${roleClass}" data-player-name="${p.name}">
          <div class="w-1/4 truncate font-bold">${p.name}${winnerBadge}</div>
          <div class="w-1/4"><input type="text" class="number-input player-chip-input w-full bg-gray-700 border border-gray-600 rounded-md p-1 text-xs" placeholder="칩" value="${formatNumber(p.chips)}"></div>
          <div class="w-1/4"><button class="keypad-icon-btn btn bg-gray-600 p-1 rounded-md text-xs w-full">⌨️</button></div>
          <div class="w-1/4 card-placeholder h-10 flex justify-center items-center gap-1" data-player-name="${p.name}" data-count="2">
            ${p.hand?.length? p.hand.map(formatCardDisplay).join('') : '<span class="text-gray-400 text-lg">+</span>'}
          </div>
        </div>`;
      }).join('');
    }
    function renderBoard(){
      const flop=`<div class="card-placeholder h-10 w-24" data-target="board" data-index="0" data-count="3">${[0,1,2].map(i=>window.state.board[i]?formatCardDisplay(window.state.board[i]):'').join('') || '<span class="text-gray-400 text-lg">+</span>'}</div>`;
      const turn=`<div class="card-placeholder h-10 w-8" data-target="board" data-index="3" data-count="1">${window.state.board[3]?formatCardDisplay(window.state.board[3]):'<span class="text-gray-400 text-lg">+</span>'}</div>`;
      const river=`<div class="card-placeholder h-10 w-8" data-target="board" data-index="4" data-count="1">${window.state.board[4]?formatCardDisplay(window.state.board[4]):'<span class="text-gray-400 text-lg">+</span>'}</div>`;
      el.boardCardPlaceholders.innerHTML = flop+turn+river;
    }
    // 최종 팟 계산 함수
    function calculateFinalPot(){
      // 실제 팟 계산 사용 (폴드한 플레이어의 베팅 포함, 언콜 베팅 제외)
      return calculateActualPot();
    }
    
    function renderWinnerSelection(){
      const finalPot = calculateFinalPot();
      
      el.winnerButtons.innerHTML = window.state.playersInHand.map(p=>{
        const sel=(p.role==='winner');
        const potDisplay = sel && finalPot > 0 ? ` <span class="text-amber-300 font-bold">+${formatNumber(finalPot)}</span>` : '';
        return `<button class="btn ${sel?'btn-selected bg-amber-600':'bg-gray-600 hover:bg-gray-500'} px-2 py-1 text-xs rounded-md set-winner-btn" data-player-name="${p.name}">${p.name}${potDisplay}</button>`;
      }).join('');
    }
    function renderActionStreets(){
      const streets=['preflop','flop','turn','river']; 
      let displayPot=0;  // UI 표시용 팟
      
      el.streetLogsContainer.innerHTML = streets.map(street=>{
        const logs=window.state.actionState[street]||[]; 
        let streetPot=0;
        
        if(street==='preflop'){
          streetPot += parseInt(unformatNumber(window.state.actionState.smallBlind)||0,10);
          streetPot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
          if(window.state.actionState.hasBBAnte) streetPot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
        }
        
        // Pot Correction이 있는지 확인
        const potCorrection = logs.find(a => a.action === 'Pot Correction');
        if(potCorrection) {
          // Pot Correction이 있으면 그 값을 직접 사용
          displayPot = parseInt(unformatNumber(potCorrection.amount),10);
        } else {
          // 일반 액션들만 더함
          logs.forEach(a=>{ 
            if(a.amount && a.action !== 'Pot Correction') {
              streetPot += parseInt(unformatNumber(a.amount),10); 
            }
          });
          displayPot += streetPot;
        }
        
        // 실제 팟 계산 (폴드한 플레이어의 베팅 포함)
        const actualPot = calculateActualPot();
        const uncalledBet = calculateUncalledBet();
        
        // 실제 팟과 표시 팟이 다른 경우를 위한 표시
        let potDisplay = formatNumber(displayPot);
        if(displayPot !== actualPot && logs.length > 0) {
          potDisplay = `${formatNumber(displayPot)} <span class="text-xs text-amber-400">(실제: ${formatNumber(actualPot)})</span>`;
        }
        const logHTML = logs.map(log=>{
          // Pot Correction은 시스템 액션이므로 player가 없음
          if(log.action === 'Pot Correction'){
            const amt = log.amount ? ` <span class="font-mono text-white">${formatNumber(log.amount)}</span>` : '';
            return `<span class="action-log-entry mr-2"><span class="text-blue-400">Pot</span>${amt}</span>`;
          }
          // 일반 플레이어 액션
          const player=window.state.playersInHand.find(p=>p.name===log.player);
          const cls=(player?.role==='winner')?'text-amber-400':'text-gray-300';
          const amt=log.amount?` <span class="font-mono text-white">${formatNumber(log.amount)}</span>`:'';
          return `<span class="action-log-entry mr-2"><span class="${cls}">${log.player || 'Unknown'}</span> ${log.action}${amt}</span>`;
        }).join('');
        const isActive = window.state.currentStreet === street;
        const streetBtnClass = isActive 
          ? 'bg-amber-500 text-black border-2 border-amber-300 shadow-lg' 
          : 'bg-gray-700 text-gray-300 border-2 border-gray-600 hover:bg-gray-600 hover:text-white';
        const containerClass = isActive 
          ? 'bg-gradient-to-r from-amber-900/40 to-yellow-900/30 border-2 border-amber-400 shadow-xl ring-2 ring-amber-500/30' 
          : 'bg-gray-900/50 border border-gray-700';
        
        return `<div class="street-container ${containerClass} p-2 rounded-md transition-all duration-300">
          <div class="flex justify-between items-center text-xs mb-1">
            <button class="street-select-btn ${streetBtnClass} px-3 py-1 rounded-md font-bold min-w-[70px] text-center transition-all cursor-pointer" 
                    data-street="${street}" style="${isActive ? 'box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);' : ''}">${street.toUpperCase()}</button>
            <div class="flex items-center gap-1">
              <span class="font-mono">Pot: ${potDisplay}</span>
              <button class="pot-keypad-btn btn bg-gray-600 px-1 py-0 rounded" data-street="${street}" data-current-pot="${displayPot}">⌨️</button>
            </div>
            <div class="flex gap-1">
              <button class="add-action-btn btn bg-indigo-600 text-white font-bold py-1 px-2 rounded" data-street="${street}">액션+</button>
              <button class="undo-action-btn btn bg-gray-600 py-1 px-2 rounded" data-street="${street}">↩</button>
            </div>
          </div>
          <div id="${street}-log" class="action-log-display text-xs whitespace-nowrap overflow-x-auto">${logHTML || '<span class="text-gray-500">No actions</span>'}</div>
        </div>`;
      }).join('');
    }
    function renderAll(){ renderPlayerSelection(); renderPlayerDetails(); renderBoard(); renderActionStreets(); renderWinnerSelection(); }
    // ====== MODALS ======
    function openModal(node, html){ node.innerHTML=html; node.classList.remove('hidden'); setTimeout(()=>node.classList.remove('opacity-0'),10); }
    function closeModal(node){ node.classList.add('opacity-0'); setTimeout(()=>node.classList.add('hidden'),300); }

    function openCardSelector(){
      const { target, player, index, count } = window.state.modalState.cardTarget;
      
      // 현재 선택된 카드들을 초기값으로 설정
      let selected = [];
      if(target === 'playerHand' && player) {
        const p = window.state.playersInHand.find(p => p.name === player);
        if(p && p.hand) selected = [...p.hand];
      } else if(target === 'board') {
        if(count === 3) { // flop
          selected = [window.state.board[0], window.state.board[1], window.state.board[2]].filter(Boolean);
        } else if(index === 3) { // turn
          if(window.state.board[3]) selected = [window.state.board[3]];
        } else if(index === 4) { // river
          if(window.state.board[4]) selected = [window.state.board[4]];
        }
      }
      
      const used=[...window.state.playersInHand.flatMap(p=>p.hand||[]), ...window.state.board].filter(Boolean);
      let deckHTML='';
      Object.keys(SUITS).forEach(suitKey=>{
        deckHTML+='<div class="flex justify-center gap-1 mb-1">';
        RANKS.forEach(rank=>{
          const id=`${rank}${suitKey}`;
          // 다른 곳에서 사용 중인 카드 체크 (현재 대상 제외)
          let usedByOthers = false;
          const othersCards = [...window.state.playersInHand.flatMap(p => {
            if(target === 'playerHand' && p.name === player) return []; // 현재 플레이어 제외
            return p.hand || [];
          })];
          if(target !== 'board') {
            othersCards.push(...window.state.board.filter(Boolean));
          }
          usedByOthers = othersCards.includes(id) && !selected.includes(id);
          
          const isSelected = selected.includes(id);
          const color=(suitKey==='h'||suitKey==='d')?'card-red':'card-black';
          const bgClass = isSelected ? 'bg-amber-300' : (usedByOthers ? 'bg-gray-600 text-gray-500' : 'bg-white hover:bg-amber-300');
          const selectedClass = isSelected ? 'selected' : '';
          
          deckHTML+=`<button class="btn card-selector-btn rounded-md w-9 h-11 ${bgClass} ${color} ${selectedClass}" data-card-id="${id}" ${usedByOthers?'disabled':''}>${rank}${SUITS[suitKey]}</button>`;
        });
        deckHTML+='</div>';
      });
      const html=`<div class="bg-gray-800 rounded-lg p-2 w-full max-w-md">
        <h2 class="text-lg font-bold text-amber-400 mb-2 text-center">카드 선택 (${count}장)</h2>
        <div id="selected-cards" class="text-center mb-2 text-sm text-gray-300">선택된 카드: <span id="selected-count">${selected.length}</span>/${count}</div>
        <div id="card-deck">${deckHTML}</div>
        <div class="flex gap-2 mt-2">
          <button id="close-card-modal" class="btn flex-1 bg-red-600 py-2 rounded-md">닫기</button>
          <button id="confirm-cards" class="btn flex-1 bg-green-600 py-2 rounded-md">확인</button>
        </div>
      </div>`;
      openModal(el.cardSelectorModal, html);
      // 카드 선택 이벤트
      const updateSelectedCount = () => {
        const counter = el.cardSelectorModal.querySelector('#selected-count');
        if(counter) counter.textContent = selected.length;
      };
      
      el.cardSelectorModal.querySelector('#card-deck').onclick=e=>{
        const btn=e.target.closest('.card-selector-btn'); if(!btn) return;
        const id=btn.dataset.cardId; const idx=selected.indexOf(id);
        if(idx>-1){ 
          // 이미 선택된 카드를 다시 클릭하면 선택 해제
          selected.splice(idx,1); 
          btn.classList.remove('selected');
          btn.classList.remove('bg-amber-300');
          btn.classList.add('bg-white', 'hover:bg-amber-300');
        }
        else if(selected.length<count){ 
          selected.push(id); 
          btn.classList.add('selected');
          btn.classList.remove('bg-white', 'hover:bg-amber-300');
          btn.classList.add('bg-amber-300');
        }
        updateSelectedCount();
      };
      
      // 확인 버튼 이벤트
      el.cardSelectorModal.querySelector('#confirm-cards').onclick=()=>{
        // 카드가 없으면 제거, 있으면 할당
        assignCard(selected.length > 0 ? selected : null);
      };
    }

    function openActionPad(street){
      if(window.state.playersInHand.length<1){ showFeedback('먼저 플레이어를 선택해주세요.', true); return; }
      window.state.modalState.actionPadStreet=street;
      // 액션 추가 시 해당 스트리트로 자동 전환
      window.state.currentStreet = street;
      
      // Folded 플레이어 제외
      const activePlayers = window.state.playersInHand.filter(p => 
        window.state.playerStatus[p.name] !== 'folded' && window.state.playerStatus[p.name] !== 'allin'
      );
      
      if(activePlayers.length === 0) {
        showFeedback('베팅 가능한 플레이어가 없습니다.', true);
        return;
      }
      
      const playersHTML=activePlayers.map(p=>`<button class="btn bg-gray-700 p-2 rounded-md" data-player-name="${p.name}">${p.name}</button>`).join('');
      const html=`<div class="bg-gray-800 rounded-lg p-4 w-full max-w-md">
        <h2 class="text-xl font-bold text-amber-400 mb-4 text-center">${street.toUpperCase()} 액션</h2>
        <div id="action-pad-players" class="grid grid-cols-3 gap-2 mb-4">${playersHTML}</div>
        <div id="action-pad-actions" class="grid grid-cols-3 gap-2 mb-4 hidden">
          <button class="btn bg-red-600 p-3 rounded-md" data-action="Folds">Fold</button>
          <button id="smart-check-call-btn" class="btn bg-green-600 p-3 rounded-md" data-action="SmartCheckCall">
            <span class="action-label">Check</span>
            <span class="amount-label"></span>
          </button>
          <button class="btn bg-amber-500 p-3 rounded-md" data-action="Bet/Raises">Bet/Raise</button>
          <button class="btn bg-red-800 font-bold col-span-3 p-3 rounded-md" data-action="All In">ALL IN</button>
        </div>
        <button id="close-action-pad" class="btn mt-4 w-full bg-gray-600 py-2 rounded-md">닫기</button>
      </div>`;
      openModal(el.actionPadModal, html);
    }

    function openKeypad(targetInput, options={}){
      window.state.modalState.keypadTarget=targetInput;
      window.state.modalState.keypadOptions=options;
      const initial = options.prefill ? options.prefill : (targetInput?targetInput.value:'');
      const html=`<div class="bg-gray-800 rounded-lg p-2 w-full max-w-xs">
        <div id="keypad-display" class="bg-gray-900 text-right text-2xl font-mono p-2 rounded mb-2 h-12">${initial}</div>
        <div class="grid grid-cols-3 gap-2 text-xl font-bold">
          ${['7','8','9','4','5','6','1','2','3','0','00','000'].map(k=>`<button class="keypad-btn btn bg-gray-700 p-3 rounded-md">${k}</button>`).join('')}
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">C</button>
          <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">←</button>
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <button id="keypad-cancel" class="btn bg-red-600 p-3 rounded-md">취소</button>
          <button id="keypad-confirm" class="btn bg-green-600 p-3 rounded-md">확인</button>
        </div>
      </div>`;
      openModal(el.keypadModal, html);
    }

    // ====== SELECTORS & INPUTS ======
    function togglePlayerInHand(name){
      const i=window.state.playersInHand.findIndex(p=>p.name===name);
      if(i>-1) {
        // 플레이어 제거
        window.state.playersInHand.splice(i,1);
        console.log(`➖ ${name} 제거`);
      } else {
        // 플레이어 추가
        const pool=window.state.playerDataByTable[window.state.selectedTable]||[];
        const pd=pool.find(p=>p.name===name);
        const chips=pd?pd.chips:'';
        const notable=pd?pd.notable:false;
        const seat=pd?pd.seat:String(window.state.playersInHand.length + 1); // Type에서 seat 정보 가져오기
        
        // 새 플레이어 추가 시 initialChips를 현재 칩으로 설정
        console.log(`➕ ${name} 추가: 시작칩 = 현재칩 = ${chips}, 좌석 = ${seat}`);
        window.state.playersInHand.push({
          name, 
          hand:[], 
          chips, 
          initialChips:chips,  // 시작칩은 현재 칩 값으로 설정
          role:null,
          notable:notable,  // Notable 정보 추가
          seat:seat,  // Seat 정보 추가
          chipsSetAt: new Date().toISOString()  // 칩 설정 시간 기록
        });
      }
      renderPlayerSelection(); renderPlayerDetails(); renderWinnerSelection();
    }
    function setPlayerRole(name){
      const finalPot = calculateFinalPot();
      
      // 기존 승자 찾기
      const prevWinner = window.state.playersInHand.find(p => p.role === 'winner');
      
      // 기존 승자가 있으면 팟 금액 차감
      if(prevWinner && prevWinner.name !== name) {
        const prevChips = parseInt(unformatNumber(prevWinner.chips) || 0, 10);
        prevWinner.chips = (prevChips - finalPot).toString();
        prevWinner.role = null;
      }
      
      // 새 승자 설정
      const p = window.state.playersInHand.find(pp => pp.name === name);
      if(!p) return;
      
      if(p.role === 'winner') {
        // 승자 해제
        const currentChips = parseInt(unformatNumber(p.chips) || 0, 10);
        p.chips = (currentChips - finalPot).toString();
        p.role = null;
      } else {
        // 승자 설정
        const currentChips = parseInt(unformatNumber(p.chips) || 0, 10);
        p.chips = (currentChips + finalPot).toString();
        p.role = 'winner';
        
        // 다른 모든 플레이어의 role 해제
        window.state.playersInHand.forEach(player => {
          if(player.name !== name) player.role = null;
        });
      }
      
      // 칩 변경 타임스탬프 기록
      p.chipsUpdatedAt = new Date().toISOString();
      
      renderPlayerDetails(); 
      renderWinnerSelection();
      renderActionStreets(); // 액션 로그에도 승자 하이라이트 업데이트
    }
    function assignCard(cards){
      const {target,player,index,count} = window.state.modalState.cardTarget;
      if(target==='board'){
        if(!cards || cards.length === 0) {
          // 카드 제거
          if(count === 3) { // flop
            window.state.board[0] = null;
            window.state.board[1] = null;
            window.state.board[2] = null;
          } else if(index === 3) { // turn
            window.state.board[3] = null;
          } else if(index === 4) { // river
            window.state.board[4] = null;
          }
        } else {
          // 보드 배열이 충분한 크기인지 확인
          while(window.state.board.length <= Math.max(index + count - 1, 4)) {
            window.state.board.push(null);
          }
          
          // 카드 할당 (기존 카드 유지하면서 새 카드만 업데이트)
          if(count === 3) { // flop: 인덱스 0,1,2
            window.state.board[0] = cards[0] || null;
            window.state.board[1] = cards[1] || null;
            window.state.board[2] = cards[2] || null;
          } else {
            // turn(index=3) 또는 river(index=4): 해당 인덱스만 업데이트
            window.state.board[index] = cards[0] || null;
          }
        }
        renderBoard();
      }
      else{
        const p=window.state.playersInHand.find(pp=>pp.name===player);
        if(p){ 
          p.hand = cards || []; // null이면 빈 배열로
          renderPlayerDetails();
        }
      }
      closeModal(el.cardSelectorModal);
    }
    function addActionToLog(action, amount=null){
      const { actionPadStreet, actionPadPlayer } = window.state.modalState;
      
      // 플레이어 상태 업데이트
      if (action === 'Folds') {
        window.state.playerStatus[actionPadPlayer] = 'folded';
      } else if (action === 'All In') {
        window.state.playerStatus[actionPadPlayer] = 'allin';
      }
      
      if (amount){
        const p = window.state.playersInHand.find(pp => pp.name === actionPadPlayer);
        if (p){
          const cur = parseInt(unformatNumber(p.chips) || 0, 10);
          const amountToDeduct = parseInt(unformatNumber(amount), 10);
          
          // All In의 경우 칩을 0으로 만들기
          if(action === 'All In') {
            p.chips = '0';
          } else {
            // 일반 베팅의 경우 차감
            const newChips = Math.max(0, cur - amountToDeduct);
            p.chips = newChips.toString();
          }
          p.chipsUpdatedAt = new Date().toISOString(); // ★ 프로그램적 변경도 타임스탬프 기록
        }
      }
      window.state.actionState[actionPadStreet].push({
        player: actionPadPlayer,
        action,
        amount,
        timestamp: new Date().toISOString()
      });
      saveActionState();
      renderAll();
      closeModal(el.actionPadModal);
      
      // 스트리트 완료 체크
      checkStreetComplete(actionPadStreet);
    }

    function undoLastAction(street){
      const last=window.state.actionState[street].pop();
      if(last&&last.amount){
        const p=window.state.playersInHand.find(pp=>pp.name===last.player);
        if(p){ const cur=parseInt(unformatNumber(p.chips)||0,10); p.chips=(cur+parseInt(unformatNumber(last.amount),10)).toString(); }
      }
      saveActionState(); renderAll();
    }

    // ====== PERSIST (localStorage) ======
    function saveActionState(){ localStorage.setItem('phl_v46_state', JSON.stringify(window.state.actionState)); }
    function loadActionState(){ const s=localStorage.getItem('phl_v46_state'); if(s) window.state.actionState={...window.state.actionState, ...JSON.parse(s)}; }

    // ====== SMART CHECK/CALL ======
    function getSmartCheckCallAction(player, street) {
      const actions = window.state.actionState[street];
      let lastBet = null;
      let requiredAmt = 0;
      
      // 현재 스트리트에서만 마지막 베팅 찾기 (각 스트리트는 독립적)
      for(let i = actions.length - 1; i >= 0; i--) {
        const action = actions[i];
        if(['Bets', 'Raises', 'All In'].includes(action.action) && action.amount) {
          lastBet = action;
          break;
        }
      }
      
      const p = window.state.playersInHand.find(pp => pp.name === player);
      const playerChips = p ? parseInt(unformatNumber(p.chips), 10) : 0;
      
      if(!lastBet) {
        // 현재 스트리트에 베팅 없음 → CHECK
        if(street === 'preflop') {
          // 프리플랍에서 베팅 없으면 빅블라인드 콜
          requiredAmt = unformatNumber(window.state.actionState.bigBlind);
          if(playerChips <= parseInt(requiredAmt, 10)) {
            return { action: 'All In', amount: p.chips, label: `All-in ${formatNumber(p.chips)}` };
          }
          return { action: 'Calls', amount: requiredAmt, label: `Call ${formatNumber(requiredAmt)}` };
        }
        // 플랍, 턴, 리버에서는 각 스트리트가 새로 시작되므로 체크 가능
        return { action: 'Checks', amount: null, label: 'Check' };
      } else {
        // 현재 스트리트에 베팅 있음 → CALL
        requiredAmt = lastBet.amount;
        if(playerChips <= parseInt(unformatNumber(requiredAmt), 10)) {
          // 칩 부족 → ALL-IN
          return { action: 'All In', amount: p.chips, label: `All-in ${formatNumber(p.chips)}` };
        } else {
          // 일반 CALL
          return { action: 'Calls', amount: requiredAmt, label: `Call ${formatNumber(requiredAmt)}` };
        }
      }
    }
    
    // ====== STREET COMPLETE CHECK ======
    function checkStreetComplete(street) {
      const actions = window.state.actionState[street];
      const activePlayers = window.state.playersInHand.filter(p => 
        window.state.playerStatus[p.name] !== 'folded'
      );
      const bettingPlayers = activePlayers.filter(p =>
        window.state.playerStatus[p.name] !== 'allin'
      );
      
      // 1. 핸드 종료 체크
      if(activePlayers.length === 1) {
        showFeedback(`${activePlayers[0].name} 승리!`);
        return { status: 'HAND_END', winner: activePlayers[0].name };
      }
      
      // 2. 올인 쇼다운 체크
      if(bettingPlayers.length <= 1) {
        showFeedback('올인 쇼다운! 나머지 카드를 오픈하세요.');
        return { status: 'SHOWDOWN' };
      }
      
      // 3. 스트리트 완료 체크
      if(actions.length === 0) return { status: 'WAITING' };
      
      const lastAction = actions[actions.length - 1];
      if(!['Checks', 'Calls', 'Folds'].includes(lastAction.action)) {
        return { status: 'WAITING' };
      }
      
      // 각 플레이어의 총 베팅액 계산
      const playerBets = {};
      actions.forEach(a => {
        if(a.amount && a.player) {
          playerBets[a.player] = (playerBets[a.player] || 0) + parseInt(unformatNumber(a.amount), 10);
        }
      });
      
      // 베팅 가능한 플레이어들의 베팅액 확인
      const betAmounts = bettingPlayers.map(p => playerBets[p.name] || 0);
      const maxBet = Math.max(...betAmounts, 0);
      const allEqual = betAmounts.every(amt => amt === maxBet);
      
      if(allEqual) {
        const nextStreet = getNextStreet(street);
        if(nextStreet) {
          showFeedback(`${street} 완료! ${nextStreet}로 진행`);
          // 자동 진행 옵션이 있다면 여기서 처리
          return { status: 'STREET_COMPLETE', nextStreet };
        }
      }
      
      return { status: 'WAITING' };
    }
    
    function getNextStreet(current) {
      const streets = ['preflop', 'flop', 'turn', 'river'];
      const idx = streets.indexOf(current);
      return idx >= 0 && idx < 3 ? streets[idx + 1] : null;
    }
    
    // ====== POT ======
    // 플레이어별 총 기여액 계산 (폴드한 플레이어 포함)
    function calculatePlayerContributions() {
      const contributions = {};
      const playersInHand = window.state.playersInHand || [];
      
      // 1. 모든 플레이어 초기화
      playersInHand.forEach(player => {
        contributions[player.name] = 0;
      });
      
      // 2. 블라인드와 안티 먼저 추가
      playersInHand.forEach(player => {
        const playerName = player.name;
        
        // 스몰 블라인드 (첫 번째 플레이어)
        if (player.role === 'SB' || playersInHand.indexOf(player) === 0) {
          const sbAmount = parseInt(unformatNumber(window.state.actionState.smallBlind) || 0, 10);
          contributions[playerName] += sbAmount;
        }
        
        // 빅 블라인드 (두 번째 플레이어)  
        if (player.role === 'BB' || playersInHand.indexOf(player) === 1) {
          const bbAmount = parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
          contributions[playerName] += bbAmount;
        }
        
        // BB 안티 (모든 플레이어)
        if (window.state.actionState.hasBBAnte) {
          const bbAmount = parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
          contributions[playerName] += bbAmount;
        }
      });
      
      // 3. 액션 기반 기여액 추가 (올인 제한 고려)
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        const actions = window.state.actionState[street] || [];
        
        actions.forEach(action => {
          if(action.amount && action.player && action.action !== 'Pot Correction') {
            const player = action.player;
            const amount = parseInt(unformatNumber(action.amount), 10);
            
            // 해당 플레이어의 최대 칩 찾기
            const playerData = playersInHand.find(p => p.name === player);
            const maxChips = playerData ? parseInt(unformatNumber(playerData.initialChips) || 0, 10) : Infinity;
            
            // 현재 기여액 + 새 액션이 최대 칩을 초과하지 않도록 제한
            const currentContribution = contributions[player] || 0;
            const allowedAmount = Math.min(amount, Math.max(0, maxChips - currentContribution));
            
            contributions[player] = currentContribution + allowedAmount;
            
            if (allowedAmount < amount) {
              console.log(`⚠️ ${player}: ${amount} 요청 → ${allowedAmount} 제한 (최대: ${maxChips}, 현재: ${currentContribution})`);
            }
          }
        });
      });
      
      console.log('📊 플레이어별 기여액 (올인 제한 적용):', contributions);
      return contributions;
    }
    
    // 실제 팟 계산 (올인 제한과 사이드팟을 고려한 정확한 계산)
    function calculateActualPot() {
      console.log(`%c🎲 === 새로운 팟 계산 시작 [v2.7.0] ===`, 'color: #10b981; font-weight: bold');
      
      // Pot Correction이 있으면 기존 로직 사용
      let potCorrectionFound = false;
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        const actions = window.state.actionState[street] || [];
        if(actions.find(a => a.action === 'Pot Correction')) {
          potCorrectionFound = true;
        }
      });
      
      if(potCorrectionFound) {
        return calculatePotWithCorrection();
      }
      
      // 새로운 정확한 팟 계산
      const result = calculateAccuratePot();
      console.log(`%c🎲 === 팟 계산 종료 [v2.7.0] ===`, 'color: #10b981; font-weight: bold');
      return result.totalPot;
    }
    
    // 정확한 팟 계산 (올인 제한 고려)
    function calculateAccuratePot() {
      const playersInHand = window.state.playersInHand || [];
      if (playersInHand.length === 0) {
        return { totalPot: 0, mainPot: 0, sidePots: [] };
      }
      
      // 1. 각 플레이어의 총 베팅 가능 금액 계산 (초기 칩)
      const playerMaxBets = {};
      playersInHand.forEach(player => {
        playerMaxBets[player.name] = parseInt(unformatNumber(player.initialChips) || 0, 10);
      });
      
      console.log('💰 플레이어별 최대 베팅 가능:', playerMaxBets);
      
      // 2. 실제 베팅 금액 계산 (블라인드 + 안티 + 액션)
      const playerBets = calculatePlayerContributions();
      console.log('📊 플레이어별 실제 베팅:', playerBets);
      
      // 3. 올인 플레이어들의 금액대별로 팟 분리
      const allInAmounts = [];
      playersInHand.forEach(player => {
        const playerName = player.name;
        const maxBet = playerMaxBets[playerName];
        const actualBet = Math.min(playerBets[playerName] || 0, maxBet);
        
        if (actualBet > 0 && !allInAmounts.includes(actualBet)) {
          allInAmounts.push(actualBet);
        }
      });
      
      allInAmounts.sort((a, b) => a - b);
      console.log('🎯 올인 금액대:', allInAmounts);
      
      // 4. 가장 작은 올인 금액이 메인팟 기준
      const mainPotCap = Math.min(...allInAmounts);
      let totalPot = 0;
      
      // 메인팟: 모든 플레이어가 mainPotCap만큼 기여
      const eligiblePlayers = playersInHand.filter(p => 
        window.state.playerStatus[p.name] !== 'folded'
      );
      
      const mainPot = mainPotCap * eligiblePlayers.length;
      totalPot = mainPot;
      
      console.log(`🎲 메인팟: ${mainPot} (${eligiblePlayers.length}명 × ${mainPotCap})`);
      
      // 사이드팟은 현재 구현하지 않고 메인팟만 반환
      // (대부분의 경우 2명이므로 사이드팟이 불필요)
      
      return { 
        totalPot: totalPot,
        mainPot: mainPot,
        sidePots: []
      };
    }
    
    // 기존 Pot Correction 로직
    function calculatePotWithCorrection() {
      let totalPot = 0;
      let potCorrectionValue = 0;
      let additionalBets = 0;
      
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        const actions = window.state.actionState[street] || [];
        
        const potCorrectionIdx = actions.findIndex(a => a.action === 'Pot Correction');
        if(potCorrectionIdx !== -1) {
          const potCorrection = actions[potCorrectionIdx];
          potCorrectionValue = parseInt(unformatNumber(potCorrection.amount), 10);
          
          for(let i = potCorrectionIdx + 1; i < actions.length; i++) {
            if(actions[i].amount && actions[i].action !== 'Pot Correction') {
              additionalBets += parseInt(unformatNumber(actions[i].amount), 10);
            }
          }
          return;
        }
        
        actions.forEach(action => {
          if(action.amount && action.action !== 'Pot Correction') {
            totalPot += parseInt(unformatNumber(action.amount), 10);
          }
        });
      });
      
      if(potCorrectionValue > 0) {
        totalPot = potCorrectionValue + additionalBets;
      } else {
        totalPot += parseInt(unformatNumber(window.state.actionState.smallBlind) || 0, 10);
        totalPot += parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
        if(window.state.actionState.hasBBAnte) {
          const bbAmount = parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
          totalPot += bbAmount * (window.state.playersInHand || []).length;
        }
      }
      
      return totalPot;
    }
    
    // 언콜 베팅 계산
    function calculateUncalledBet() {
      const contributions = calculatePlayerContributions();
      const activePlayers = window.state.playersInHand.filter(p => 
        window.state.playerStatus[p.name] !== 'folded'
      );
      
      // 활성 플레이어가 1명일 때만 언콜 베팅 계산
      if(activePlayers.length === 1) {
        const winner = activePlayers[0];
        const winnerContribution = contributions[winner.name] || 0;
        
        // 다른 플레이어들의 최대 기여액
        const otherMaxContribution = Math.max(
          ...Object.entries(contributions)
            .filter(([player]) => player !== winner.name)
            .map(([_, amount]) => amount),
          0
        );
        
        // 언콜 베팅 = 승자 기여액 - 타 플레이어 최대 기여액
        const uncalledAmount = Math.max(0, winnerContribution - otherMaxContribution);
        
        return {
          amount: uncalledAmount,
          player: winner.name
        };
      }
      
      return { amount: 0, player: null };
    }
    
    // 기존 calculatePotSize 함수는 UI 표시용으로 유지
    function calculatePotSize(){
      let pot=0;
      let potCorrectionFound = false;
      let potCorrectionValue = 0;
      
      // 모든 스트리트 순회
      ['preflop','flop','turn','river'].forEach(st=> {
        const actions = window.state.actionState[st];
        
        // Pot Correction 찾기
        const correctionIdx = actions.findIndex(a => a.action === 'Pot Correction');
        if(correctionIdx !== -1) {
          potCorrectionFound = true;
          potCorrectionValue = parseInt(unformatNumber(actions[correctionIdx].amount), 10);
          
          // Pot Correction 이후의 액션들만 추가
          for(let i = correctionIdx + 1; i < actions.length; i++) {
            if(actions[i].amount && actions[i].action !== 'Pot Correction') {
              pot += parseInt(unformatNumber(actions[i].amount), 10);
            }
          }
        } else if(potCorrectionFound) {
          // Pot Correction 이후의 스트리트
          actions.forEach(a => {
            if(a.amount && a.action !== 'Pot Correction') {
              pot += parseInt(unformatNumber(a.amount), 10);
            }
          });
        } else {
          // Pot Correction 이전의 액션들
          actions.forEach(a => {
            if(a.amount && a.action !== 'Pot Correction') {
              pot += parseInt(unformatNumber(a.amount), 10);
            }
          });
        }
      });
      
      // Pot Correction이 없으면 블라인드/앤티 추가
      if(!potCorrectionFound) {
        pot += parseInt(unformatNumber(window.state.actionState.smallBlind)||0,10);
        pot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
        if(window.state.actionState.hasBBAnte) {
          pot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
        }
      } else {
        // Pot Correction 값이 기준
        pot = potCorrectionValue + pot;
      }
      
      return pot;
    }

    // ====== CSV LOADERS ======
    async function fetchCsv(url){
      const res=await fetch(url); if(!res.ok) throw new Error(`CSV fetch failed: ${res.status}`);
      const txt=await res.text(); return parseCSV(txt);
    }

    function buildTypeFromCsv(rows){
      // Type 시트 구조:
      // A:Camera Preset, B:Player, C:Table, D:Notable, E:Chips, F:updatedAt, G:Seat
      // A2: Cam1 name, A3: Cam2 name (카메라 프리셋 정보)
      if(!rows||rows.length<1) return;
      const header=rows[0];
      const A2=(rows[1]&&rows[1][0])?String(rows[1][0]).trim():'';
      const A3=(rows[2]&&rows[2][0])?String(rows[2][0]).trim():'';
      window.state.camPreset.cam1=A2||'Cam1';
      window.state.camPreset.cam2=A3||'Cam2';
      // localStorage에서 마지막 카메라 번호 읽어서 표시
      const lastCam1No = localStorage.getItem('pokerHandLogger_lastCam1');
      const lastCam2No = localStorage.getItem('pokerHandLogger_lastCam2');
      
      console.log(`🎞️ 카메라 버튼 초기화:`);
      console.log(`  ${window.state.camPreset.cam1} 저장된 번호: ${lastCam1No || '없음'}`);
      console.log(`  ${window.state.camPreset.cam2} 저장된 번호: ${lastCam2No || '없음'}`);
      
      if(lastCam1No) {
        const nextNo = parseInt(lastCam1No, 10) + 1;
        el.cam1.textContent = `${window.state.camPreset.cam1}${pad4(nextNo)}`;
        console.log(`  → ${window.state.camPreset.cam1} 표시: ${pad4(nextNo)}`);
      } else {
        el.cam1.textContent = `${window.state.camPreset.cam1}0001`;
        console.log(`  → ${window.state.camPreset.cam1} 표시: 0001 (초기값)`);
      }
      
      if(lastCam2No) {
        const nextNo = parseInt(lastCam2No, 10) + 1;
        el.cam2.textContent = `${window.state.camPreset.cam2}${pad4(nextNo)}`;
        console.log(`  → ${window.state.camPreset.cam2} 표시: ${pad4(nextNo)}`);
      } else {
        el.cam2.textContent = `${window.state.camPreset.cam2}0001`;
        console.log(`  → ${window.state.camPreset.cam2} 표시: 0001 (초기값)`);
      }

      const byTable={};
      for(let i=1;i<rows.length;i++){
        const r=rows[i]||[];
        // A:Camera Preset, B:Player, C:Table, D:Notable, E:Chips, F:updatedAt, G:Seat
        const player=String(r[1]||'').trim();
        const table =String(r[2]||'').trim();
        const notable = String(r[3]||'').toUpperCase()==='TRUE';
        const chips = String(r[4]!=null?r[4]:'0').trim();
        const updatedAt = String(r[5]||'').trim(); // F열: updatedAt
        const seat = String(r[6]||'').trim(); // G열: Seat
        
        if(player && table){
          if(!byTable[table]) byTable[table]=[];
          if(!byTable[table].some(p=>p.name===player)){
            byTable[table].push({
              name: player, 
              chips, 
              notable,
              updatedAt,
              seat
            });
          }
        }
      }
      window.state.playerDataByTable=byTable;
      window.state.allTables=Object.keys(byTable).sort();
    }

    function buildIndexFromCsv(rows){
      // Index CSV columns:
      // A handNumber | B startRow | C endRow | D handUpdatedAt | E handEdit | F handEditTime | G label | H table | I tableUpdatedAt | J Cam | K CamFile01name | L CamFile01number | M CamFile02name | N CamFile02number
      // O lastStreet | P lastAction | Q workStatus (새로운 열들)
      const out=[]; for(let i=1;i<rows.length;i++){
        const r=rows[i]||[];
        const item={
          handNumber:String(r[0]||''), startRow:+(r[1]||0), endRow:+(r[2]||0),
          handUpdatedAt:String(r[3]||''), handEdit:r[4], handEditTime:r[5], label:r[6],
          table:String(r[7]||''), tableUpdatedAt:r[8], cam:r[9], cam1:r[10], cam1no:r[11], cam2:r[12], cam2no:r[13],
          lastStreet:String(r[14]||''), lastAction:String(r[15]||''), workStatus:String(r[16]||'')  // 새로운 열들
        };
        if(item.handNumber) out.push(item);
      }
      window.state.indexRows=out;
      // 최신 우선 정렬
      out.sort((a,b)=> a.handUpdatedAt<b.handUpdatedAt?1:-1);
      window.state.allHandNumbers = [...new Set(out.map(x=>x.handNumber))];
    }

    // 파싱: Hand CSV → 특정 handNumber의 "가장 최근 updatedAt" 블록
    function parseHandBlock(rows, handNumber, preferDate){
      // HAND 시작 위치 수집
      const starts=[];
      for(let r=0;r<rows.length;r++){
        const row=rows[r]||[];
        if(row[1]==='HAND'){
          const no=String(row[2]||'');
          if(no===String(handNumber)){
            starts.push({r});
          }
        }
      }
      if(!starts.length) return null;
    
      // Index에서 최신 updatedAt 기준 블록 범위 찾기
      let updatedAt=preferDate||null;
      if(!updatedAt){
        const candidates=window.state.indexRows.filter(x=>x.handNumber===String(handNumber));
        candidates.sort((a,b)=> a.handUpdatedAt<b.handUpdatedAt?1:-1);
        updatedAt=candidates[0]?.handUpdatedAt||null;
      }
      let startRowIdx=-1, endRowIdx=-1;
      const idxRow=window.state.indexRows.find(x=>x.handNumber===String(handNumber) && x.handUpdatedAt===updatedAt);
      if(idxRow){ startRowIdx=idxRow.startRow-1; endRowIdx=idxRow.endRow-1; }
      else{
        const last=starts[starts.length-1].r;
        startRowIdx=last;
        let r=last+1; while(r<rows.length && rows[r][1]!=='HAND') r++;
        endRowIdx=r-1;
      }
      if(startRowIdx<0 || endRowIdx<startRowIdx) return null;
    
      const block=rows.slice(startRowIdx,endRowIdx+1);
    
      // 파싱
      let handInfo=null, players=[], board=[], smallBlind='', bigBlind='', ante=0, table='';
      // 스트리트 분할: 블록을 **순서대로** 돌면서 BOARD를 만날 때마다 전환한다
      const streets={preflop:[],flop:[],turn:[],river:[]};
      let street='preflop';
      let seenBoard=0;
    
      for(const row of block){
        if(row[1]==='HAND'){
          handInfo=row;
          ante=parseInt(row[6]||0,10)||0;
          smallBlind=row[8]||'';
          bigBlind=row[9]||'';
          table=row[17]||'';
        }else if(row[1]==='PLAYER'){
          const name=row[2];
          const seat=row[3];
          // PLAYER 파싱: row[4]는 0, row[5]는 시작칩, row[6]은 종료칩, row[7]은 핸드
          const init=row[5], final=row[6];
          const cards=(row[7]||'').trim()? String(row[7]).trim().split(' ') : [];
          players.push({name, seat, initialChips:init, finalChips:final, hand:cards});
        }else if(row[1]==='EVENT'){
          const etype=String(row[2]||'').toUpperCase();
          if(etype==='BOARD'){
            // 보드 전환 지점
            const card=row[4];
            if(card) board.push(card);
            seenBoard++;
            if(seenBoard===3) street='flop';
            else if(seenBoard===4) street='turn';
            else if(seenBoard===5) street='river';
          }else{
            // 좌석 → 이름
            const seat=row[3];
            const amount=row[4];
            const time=row[5];
            const p=players.find(pp=>String(pp.seat)===String(seat));
            const name=p?p.name:'';
            streets[street].push({
              player:name,
              action:etype,
              amount:amount||null,
              timestamp:time||null
            });
          }
        }
      }

  // 승자 판단 로직 개선: 가장 많은 칩 증가량을 가진 플레이어 한 명만 승자로 지정
  let winnerName = null;
  let maxGain = 0;
  
  players.forEach(p => {
    const initial = parseInt(p.initialChips || 0, 10);
    const final = parseInt(p.finalChips || 0, 10);
    const gain = final - initial;
    
    if(gain > maxGain) {
      maxGain = gain;
      winnerName = p.name;
    }
  });

  return {
    handInfo,
    table,
    ante,
    smallBlind,
    bigBlind,
    hasBBAnte: ante>0,
    board,
    actions: streets,
    players: players.map(p=>({
      name:p.name,
      initialChips:p.initialChips,
      finalChips:p.finalChips,
      hand:p.hand,
      role: (p.name === winnerName && maxGain > 0) ? 'winner' : null
    }))
  };
}



    // ====== LOADERS (initial) ======
    async function loadInitial(){
      openLogModal(); el.logDisplay.innerHTML='';
      logMessage(`🚀 ${APP_VERSION} 초기 데이터 로딩 시작 (Type/Index) ...`);
      try{
        const [typeRows, idxRows] = await Promise.all([
          CSV_TYPE_URL.includes('http')? fetchCsv(CSV_TYPE_URL) : Promise.resolve([]),
          CSV_INDEX_URL.includes('http')? fetchCsv(CSV_INDEX_URL) : Promise.resolve([])
        ]);
        if(typeRows.length) buildTypeFromCsv(typeRows);
        if(idxRows.length) buildIndexFromCsv(idxRows);
        window.state.actionState.handNumber = (window.state.allHandNumbers.length>0? Math.max(...window.state.allHandNumbers.map(n=>parseInt(n,10)||0)) + 1 : 1).toString();
        el.handNumberDisplay.textContent = `#${window.state.actionState.handNumber}`;
        el.dataStamp.textContent = `IDX rows: ${window.state.indexRows.length}`;
        
        // Index에서 마지막 카메라 번호 찾기 및 localStorage 동기화
        logMessage('📷 카메라 번호 데이터 분석 시작...');
        
        if(window.state.indexRows.length > 0) {
          logMessage(`📊 총 ${window.state.indexRows.length}개의 핸드 데이터 검색 중...`);
          
          // 가장 최근 핸드 찾기 (핸드 번호 기준 내림차순)
          const sortedRows = window.state.indexRows.slice().sort((a,b) => {
            const numA = parseInt(a.handNumber, 10) || 0;
            const numB = parseInt(b.handNumber, 10) || 0;
            return numB - numA;
          });
          
          // 카메라 번호가 있는 가장 최근 핸드 찾기
          let maxCam1 = 0, maxCam2 = 0;
          let foundInHand = null;
          
          for(const row of sortedRows) {
            const cam1Num = parseInt(row.cam1no, 10) || 0;
            const cam2Num = parseInt(row.cam2no, 10) || 0;
            
            if(cam1Num > maxCam1) {
              maxCam1 = cam1Num;
              if(!foundInHand) foundInHand = row.handNumber;
            }
            if(cam2Num > maxCam2) {
              maxCam2 = cam2Num;
              if(!foundInHand) foundInHand = row.handNumber;
            }
          }
          
          if(foundInHand) {
            logMessage(`📍 핸드 #${foundInHand}에서 카메라 번호 발견`);
          }
          
          if(maxCam1 > 0) {
            localStorage.setItem('pokerHandLogger_lastCam1', String(maxCam1));
            logMessage(`✅ ${window.state.camPreset.cam1} 마지막 번호: ${maxCam1} → 다음 번호: ${pad4(maxCam1 + 1)}`);
          } else {
            logMessage(`⚠️ ${window.state.camPreset.cam1} 번호 데이터 없음 → 0001부터 시작`);
          }
          
          if(maxCam2 > 0) {
            localStorage.setItem('pokerHandLogger_lastCam2', String(maxCam2));
            logMessage(`✅ ${window.state.camPreset.cam2} 마지막 번호: ${maxCam2} → 다음 번호: ${pad4(maxCam2 + 1)}`);
          } else {
            logMessage(`⚠️ ${window.state.camPreset.cam2} 번호 데이터 없음 → 0001부터 시작`);
          }
        } else {
          logMessage('⚠️ Index 데이터가 비어있음 → 카메라 번호 0001부터 시작');
        }
        
        renderAll();
        logMessage(`✅ ${APP_VERSION} 초기 데이터 로딩 완료`);
      }catch(err){
        console.error(err); logMessage(`초기 로딩 실패: ${err.message}`, true);
      }finally{
        setTimeout(closeLogModal, 800);
      }
    }

    // ====== LOAD HAND MODAL ======
    function openLoadHandModal(){
      console.log('📂 Load Hand 모달 열기 시도...');
      console.log('📋 Index 행 개수:', window.state.indexRows.length);
      
      if(!window.state.indexRows.length){
        console.error('❌ Index 데이터 없음');
        showFeedback('Index 데이터가 없습니다. CSV 게시와 URL을 확인하세요.', true);
        return;
      }
      
      // 핸드 번호 기준 내림차순 정렬 (최신 핸드가 위로)
      const items = window.state.indexRows.slice().sort((a,b)=> {
        const numA = parseInt(a.handNumber, 10) || 0;
        const numB = parseInt(b.handNumber, 10) || 0;
        return numB - numA; // 내림차순
      });
      
      const htmlItems = items.map(it=>{
        // 상태 아이콘 결정
        const statusIcon = {
          '완료': '✅',
          '진행중': '🔄',
          '검토필요': '⚠️'
        }[it.workStatus] || '📝';
        
        // 스트리트 배지 색상과 스타일
        const streetColors = {
          'preflop': 'bg-green-500 text-white',
          'flop': 'bg-blue-500 text-white',
          'turn': 'bg-orange-500 text-white',
          'river': 'bg-red-500 text-white'
        };
        const streetBadge = it.lastStreet ? 
          `<span class="${streetColors[it.lastStreet] || 'bg-gray-500 text-white'} px-2 py-0.5 rounded text-xs font-bold">${it.lastStreet?.toUpperCase() || ''}</span>` : '';
        
        // 버튼 배경색 (상태별)
        const btnBgClass = it.workStatus === '완료' ? 'bg-gray-800' : 
                          it.workStatus === '검토필요' ? 'bg-yellow-900/30' : 'bg-gray-700';
        
        return `<button class="btn ${btnBgClass} p-2 rounded-md w-full text-left load-hand-item-btn mb-2 hover:bg-gray-600 transition-all" 
                data-no="${it.handNumber}" data-date="${it.handUpdatedAt}">
          <div class="flex justify-between items-center mb-1">
            <span class="font-bold text-white flex items-center gap-1">
              ${statusIcon} #${it.handNumber}
            </span>
            ${streetBadge}
            <span class="text-xs text-amber-400 truncate max-w-[100px]">${it.table||''}</span>
          </div>
          <div class="flex justify-between items-center">
            <span class="text-xs text-gray-400">${it.lastAction || '액션 없음'}</span>
            <span class="text-xs text-gray-500">${it.handUpdatedAt||''}</span>
          </div>
        </button>`;
      }).join('');
      
      const html = `<div class="bg-gray-800 rounded-lg p-4 w-full max-w-md flex flex-col h-2/3">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold text-amber-400">핸드 불러오기</h2>
          <button id="close-load-hand-modal" class="text-2xl">&times;</button>
        </div>
        <div class="overflow-y-auto space-y-2 flex-grow pr-2">${htmlItems}</div>
      </div>`;
      openModal(el.loadHandModal, html);
      
      // 모달 밖 클릭 시 닫기 (기존 이벤트 리스너와 충돌 방지)
      // onclick 대신 별도의 이벤트 리스너 사용
    }
    async function ensureHandCsv(){
      if(window.state.handCsvCache) return window.state.handCsvCache;
      logMessage('Hand CSV 다운로드 중...');
      const rows = await fetchCsv(CSV_HAND_URL + `&cb=${Date.now()}`);
      window.state.handCsvCache = rows;
      logMessage(`Hand CSV 로드 완료 (rows=${rows.length})`);
      return rows;
    }

    async function loadHandData(handNumber, preferDate){
      console.log(`📥 핸드 #${handNumber} 불러오기 시작...`);
      try{
        const rows = await ensureHandCsv();
        console.log(`📊 Hand CSV 로드 완료: ${rows.length} 행`);
        
        const data = parseHandBlock(rows, handNumber, preferDate);
        console.log('📝 파싱된 데이터:', data);
        
        if(!data){ 
          console.error(`❌ Hand #${handNumber} 데이터를 찾을 수 없음`);
          showFeedback(`Hand #${handNumber} 블록을 찾을 수 없습니다.`, true); 
          return; 
        }

        // 상태 초기화
        window.state.playersInHand=[];
        window.state.board = data.board||[];
        window.state.playerStatus = {}; // 플레이어 상태 초기화 추가
        
        window.state.actionState = {
          ...window.state.actionState,
          handNumber: String(handNumber),
          smallBlind: data.smallBlind || '',
          bigBlind: data.bigBlind || '',
          hasBBAnte: data.ante>0,
          preflop: data.actions?.preflop||[],
          flop: data.actions?.flop||[],
          turn: data.actions?.turn||[],
          river: data.actions?.river||[],
        };
        window.state.selectedTable = data.table || '';
        updateSelectedTableDisplay();

        window.state.playersInHand = (data.players||[]).map(p=>({
          name:p.name, hand:p.hand||[], chips:p.finalChips, initialChips:p.initialChips, role:p.role||null
        }));
        
        // 플레이어 상태 복원 (액션에서 폴드/올인 확인)
        ['preflop', 'flop', 'turn', 'river'].forEach(street => {
          (data.actions?.[street] || []).forEach(action => {
            if(action.player && action.action === 'Folds') {
              window.state.playerStatus[action.player] = 'folded';
            } else if(action.player && action.action === 'All In') {
              window.state.playerStatus[action.player] = 'allin';
            }
          });
        });

        el.handNumberDisplay.textContent = `#${handNumber}`;
        el.smallBlindInput.value = formatNumber(window.state.actionState.smallBlind);
        el.bigBlindInput.value = formatNumber(window.state.actionState.bigBlind);
        el.bbAnteCheckbox.checked = window.state.actionState.hasBBAnte;

        // currentStreet 결정: Index에서 저장된 값 우선, 없으면 액션으로 판단
        const indexRow = window.state.indexRows.find(r => r.handNumber === String(handNumber));
        console.log(`🔍 핸드 #${handNumber} 로드 중...`);
        console.log('📋 Index 행 데이터:', indexRow);
        
        if(indexRow) {
          // 카메라 정보 로드 및 로깅
          if(indexRow.cam1 || indexRow.cam1no) {
            console.log(`📷 카메라1 정보 발견:`);
            console.log(`   - 이름: ${indexRow.cam1 || '없음'}`);
            console.log(`   - 번호: ${indexRow.cam1no || '없음'}`);
            
            // 카메라1 정보 업데이트
            if(indexRow.cam1) {
              window.state.camPreset.cam1 = indexRow.cam1;
              console.log(`📷 카메라1 프리셋 업데이트: ${indexRow.cam1}`);
            }
            if(indexRow.cam1no) {
              window.state.camNumbers.cam1no = indexRow.cam1no;
              el.cam1.textContent = window.state.camPreset.cam1 + pad4(indexRow.cam1no);
            }
          }
          
          if(indexRow.cam2 || indexRow.cam2no) {
            console.log(`📷 카메라2 정보 발견:`);
            console.log(`   - 이름: ${indexRow.cam2 || '없음'}`);
            console.log(`   - 번호: ${indexRow.cam2no || '없음'}`);
            
            // 카메라2 정보 업데이트
            if(indexRow.cam2) {
              window.state.camPreset.cam2 = indexRow.cam2;
              console.log(`📷 카메라2 프리셋 업데이트: ${indexRow.cam2}`);
            }
            if(indexRow.cam2no) {
              window.state.camNumbers.cam2no = indexRow.cam2no;
              el.cam2.textContent = window.state.camPreset.cam2 + pad4(indexRow.cam2no);
            }
          }
          
          console.log('📊 로드 후 카메라 상태:');
          console.log(`   - cam1: ${window.state.camPreset.cam1}${pad4(window.state.camNumbers.cam1no || '0')}`);
          console.log(`   - cam2: ${window.state.camPreset.cam2}${pad4(window.state.camNumbers.cam2no || '0')}`);
          
          if(indexRow.lastStreet) {
            window.state.currentStreet = indexRow.lastStreet;
          }
          
          // 작업 상태 표시
          if(indexRow.workStatus) {
            const statusText = {
              '완료': '✅ 완료된 핸드',
              '진행중': '🔄 작업 진행 중',
              '검토필요': '⚠️ 검토 필요'
            }[indexRow.workStatus] || indexRow.workStatus;
            showFeedback(`#${handNumber} ${statusText}`);
          }
        } else {
          // 기존 로직: 액션으로 판단
          if(window.state.actionState.river.length > 0) {
            window.state.currentStreet = 'river';
          } else if(window.state.actionState.turn.length > 0) {
            window.state.currentStreet = 'turn';
          } else if(window.state.actionState.flop.length > 0) {
            window.state.currentStreet = 'flop';
          } else {
            window.state.currentStreet = 'preflop';
          }
        }

        renderAll(); saveActionState();
        
        
        closeModal(el.loadHandModal);
        showFeedback(`#${handNumber} 핸드를 불러왔습니다.`);
      }catch(err){
        console.error('핸드 불러오기 오류:', err);
        console.error('오류 스택:', err.stack);
        showFeedback(`불러오기 실패: ${err.message}`, true);
      }
    }

    // ====== GENERATE & SEND ======
    function formatISODateInTZ(date, tz){
      // yyyy-MM-dd
      const y = new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric' }).format(date);
      const m = new Intl.DateTimeFormat('en-CA', { timeZone: tz, month:'2-digit' }).format(date);
      const d = new Intl.DateTimeFormat('en-CA', { timeZone: tz, day:'2-digit' }).format(date);
      return `${y}-${m}-${d}`;
    }

    function generateRows_v46(){
      const out=[]; let no=1;
      const push=(arr)=>{ const a=[no, ...arr]; while(a.length<18) a.push(''); out.push(a); no++; };

      const epochSec = Math.floor(Date.now()/1000);
      const sb = unformatNumber(window.state.actionState.smallBlind)||'0';
      const bb = unformatNumber(window.state.actionState.bigBlind)||'0';
      const ante = window.state.actionState.hasBBAnte ? bb : '0';
      const table = window.state.selectedTable || '';
      const currentDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD 형식

      // GAME / PAYOUTS - E열(인덱스 4)에 날짜 추가
      const gameRow = ['GAME','GGProd Hand Logger','Virtual Table', currentDate];
      push(gameRow);
      push(['PAYOUTS']);

      // HAND: C no, D code, G ante, I SB, J BB, R table
      const handDate = formatISODateInTZ(new Date(), window.state.selectedTimezone); // yyyy-MM-dd
      
      // HAND: C no, D code, G ante, I SB, J BB, R table
      push(['HAND',
        String(window.state.actionState.handNumber),
        epochSec,
        'HOLDEM',
        window.state.actionState.hasBBAnte ? 'BB_ANTE':'NO_ANTE',
        ante,
        handDate, // ★ 여기(H) 칸에 날짜를 넣도록 약속 (Apps Script도 이 칸은 날짜로 쓰게)
        sb,       // I
        bb,       // J
        0,1,2,3,0,0,1,
        table     // R
      ]);

      // PLAYERS
      const players = window.state.playersInHand.map((p,i)=>({
        ...p, 
        seat: p.seat || (i+1)  // Type에서 가져온 seat 정보가 있으면 사용, 없으면 인덱스+1
      }));
      
      console.log(`%c=== PLAYER 행 생성 [v2.1.1] ===`, 'color: #3b82f6; font-weight: bold');
      console.log(`현재 행번호(no): ${no}`);
      console.log(`플레이어 수: ${players.length}`);
      console.log('%c형식: A=행번호, B=PLAYER, C=이름, D=좌석, E=0(고정), F=시작칩, G=종료칩, H=핸드', 'color: #9ca3af');
      
      players.forEach(p=>{
        console.log(`\n--- ${p.name} 처리 시작 ---`);
        console.log(`  원본 데이터:`, p);
        
        // 칩 값 확인 - initialChips가 없으면 chips 값을 사용
        let initialChips;
        let finalChips = parseInt(unformatNumber(p.chips)||0,10);
        
        // initialChips가 undefined이거나 빈 문자열인 경우 처리
        if(p.initialChips === undefined || p.initialChips === '' || p.initialChips === null) {
          console.warn(`  ⚠️ initialChips가 없음. chips 값 사용: ${p.chips}`);
          initialChips = finalChips; // 시작칩이 없으면 현재 칩을 시작칩으로 사용
        } else {
          const unformattedInitial = unformatNumber(p.initialChips);
          console.log(`  unformatNumber(p.initialChips) = "${unformattedInitial}"`);
          initialChips = parseInt(unformattedInitial || '0', 10);
          if(isNaN(initialChips)) {
            console.error(`  ❌ parseInt가 NaN 반환! 원본: "${p.initialChips}"`);
            initialChips = 0;
          }
        }
        
        // 디버깅: 실제 값 확인
        console.log(`  초기칩(raw): "${p.initialChips}" → ${initialChips}`);
        console.log(`  최종칩(raw): "${p.chips}" → ${finalChips}`);
        console.log(`  핸드: ${p.hand?.join(' ') || '(없음)'}`);
        
        // 배열 생성 전 값 타입 확인
        console.log(`  initialChips 타입: ${typeof initialChips}, 값: ${initialChips}`);
        console.log(`  finalChips 타입: ${typeof finalChips}, 값: ${finalChips}`);
        
        // PLAYER 형식: B=PLAYER, C=name, D=seat, E=0, F=시작칩, G=종료칩, H=핸드
        // push 함수가 자동으로 행번호를 A열에 추가하므로 7개 요소 필요
        const playerRow = ['PLAYER', p.name, parseInt(p.seat) || 1, 0, initialChips, finalChips, p.hand?.length? p.hand.join(' ') : ''];
        
        console.log(`  ===== PLAYER 행 생성 =====`);
        console.log(`  playerRow 배열:`, playerRow);
        console.log(`  playerRow.length: ${playerRow.length}`);
        
        // 각 요소 검증
        console.log(`  [0] = '${playerRow[0]}' (PLAYER 문자열)`);
        console.log(`  [1] = '${playerRow[1]}' (이름: ${p.name})`);
        console.log(`  [2] = ${playerRow[2]} (좌석: ${p.seat})`);
        console.log(`  [3] = ${playerRow[3]} (0 고정값)`);
        console.log(`  [4] = ${playerRow[4]} (시작칩: ${initialChips})`);
        console.log(`  [5] = ${playerRow[5]} (종료칩: ${finalChips})`);
        console.log(`  [6] = '${playerRow[6]}' (핸드)`);
        
        // push 전 현재 행번호
        const currentNo = no;
        console.log(`  push 전 행번호: ${currentNo}`);
        
        push(playerRow);
        
        // push 후 실제 저장된 데이터 확인
        const pushedRow = out[out.length - 1];
        console.log(`  push 후 저장된 행:`, pushedRow);
        console.log(`  최종 CSV 형식:`);
        console.log(`    A=${pushedRow[0]} (행번호), B=${pushedRow[1]} (PLAYER), C=${pushedRow[2]} (이름), D=${pushedRow[3]} (좌석),`);
        console.log(`    E=${pushedRow[4]} (0 고정값), F=${pushedRow[5]} (시작칩), G=${pushedRow[6]} (종료칩), H=${pushedRow[7]} (핸드)`);
        console.log(`--- ${p.name} 처리 완료 ---\n`);
      });

      // EVENTS
      const addEv=(log)=>{
        const p=players.find(x=>x.name===log.player);
        const seat=p?p.seat:'';
        const amt=log.amount? unformatNumber(log.amount):'';
        let t=(log.action||'').toUpperCase().replace(/S$/,'');
        if(t==='BET/RAISES') t='RAISE TO';
        push(['EVENT', t, seat, amt, '' ]);
      };
      window.state.actionState.preflop.forEach(addEv);
      if(window.state.board.length>=3){ push(['EVENT','BOARD',1,window.state.board[0],'' ]); push(['EVENT','BOARD',1,window.state.board[1],'' ]); push(['EVENT','BOARD',1,window.state.board[2],'' ]); }
      window.state.actionState.flop.forEach(addEv);
      if(window.state.board.length>=4){ push(['EVENT','BOARD',1,window.state.board[3],'' ]); }
      window.state.actionState.turn.forEach(addEv);
      if(window.state.board.length>=5){ push(['EVENT','BOARD',1,window.state.board[4],'' ]); }
      window.state.actionState.river.forEach(addEv);

      // 마지막 번호행(선택)
      out.push([no]); 
      return { rows: out, epochSec, currentDate };
    }
    
let isSending = false;

async function sendDataToGoogleSheet(){
  if (isSending) return;     // 중복 전송 가드
  isSending = true;

  if (window.state.playersInHand.filter(p=>p.role==='winner').length===0){
    showFeedback('승자를 선택해야 합니다.', true);
    isSending = false;
    return;
  }

  openLogModal(); logMessage('시트 전송 시작...');
  el.sendToSheetBtn.textContent='전송 중...';
  el.sendToSheetBtn.disabled=true;

  try{
    const { rows, epochSec } = generateRows_v46();
    const indexMeta   = buildIndexMeta();
    const typeUpdates = buildTypeUpdates();
    // 노트 기능 제거
    const payload = { rows, indexMeta, typeUpdates };

    // x-www-form-urlencoded로 전송 → 프리플라이트 없음 (CORS 우회)
    const form = new URLSearchParams();
    form.append('payload', JSON.stringify(payload));

    const res = await fetch(APPS_SCRIPT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' },
      body: form.toString(),
      // mode: 'cors'  // 생략 가능 (기본)
    });

    if(!res.ok){
      const text = await res.text().catch(()=> '');
      throw new Error(`서버 응답 오류: ${res.status} ${text || ''}`);
    }

    const json = await res.json().catch(()=> ({}));

    if(json.status === 'duplicate'){
      logMessage(`⚠️ 핸드 #${json.handNumber}는 이미 기록되어 있습니다.`);
      showFeedback('⚠️ 중복된 핸드입니다', true);
      // 중복인 경우에도 핸드 번호를 증가시켜야 함
      const currentNo = parseInt(window.state.actionState.handNumber, 10) || 0;
      window.state.actionState.handNumber = String(currentNo + 1);
      el.handNumberDisplay.textContent = `#${window.state.actionState.handNumber}`;
      
      // 중복이어도 시트에는 기록됐으므로 새 핸드로 재설정
      await resetApp();
      logMessage('✅ 새 핸드 준비 완료');
      
    } else if(json.status !== 'success'){
      logMessage('⚠️ Apps Script가 success를 반환하지 않았습니다.');
      logMessage('⚠️ 시트 확인 후 수동으로 재설정 버튼을 눌러주세요.');
      showFeedback('⚠️ 시트 전송 확인 필요', true);
      // 성공 여부가 불확실하므로 자동 재설정하지 않음
      
    } else {
      logMessage(`✅ 저장 완료: #${json.handNumber || indexMeta.handNumber} (rows=${json.rowsAdded})`);
      showFeedback('✅ 시트 기록 완료');
      
      // 시트가 업데이트되도록 충분한 시간을 기다림
      logMessage('시트 동기화 중...');
      await sleep(3000); // 3초 대기
      
      // Index CSV 리프레시
      try{
        if(CSV_INDEX_URL.includes('http')){
          const idxRows = await fetchCsv(CSV_INDEX_URL + `&cb=${Date.now()}`);
          buildIndexFromCsv(idxRows);
          el.dataStamp.textContent = `IDX rows: ${window.state.indexRows.length}`;
        }
      }catch(_){ /* noop */ }
      
      // 성공적으로 저장된 경우에만 새 핸드로 재설정
      // 시트 전송 직후에는 Index 재로드 없이 바로 다음 번호로 이동
      await resetApp(false, true);
      logMessage(`✅ ${APP_VERSION} 새 핸드 준비 완료`);
    }

  }catch(err){
    console.error(err);
    logMessage(`❌ 전송 실패: ${err.message}`, true);
    showFeedback(`❌ 전송 실패: ${err.message}`, true);
    // 전송 실패 시에는 재설정하지 않음
    logMessage('⚠️ 다시 시도하거나 수동으로 재설정해주세요.');
  }finally{
    isSending = false;
    el.sendToSheetBtn.textContent='시트 전송';
    el.sendToSheetBtn.disabled=false;
    setTimeout(()=>closeLogModal(), 3000); // 로그를 좀 더 오래 보여줌
  }
}


    function nowIso() {
      // 서버에서 timezone 변환하므로 UTC ISO로 보냄
      return new Date().toISOString();
    }
    function buildIndexMeta(){
      const handNumber = String(window.state.actionState.handNumber);
      const handUpdatedAt = new Date().toISOString().split('T')[0]; // YYYY-MM-DD 형식
      const table = window.state.selectedTable || '';
      
      // 카메라 정보 로깅
      console.log('📦 Index 메타데이터 빌드:');
      console.log(`  cam1: ${window.state.camPreset.cam1} / 번호: ${window.state.camNumbers.cam1no}`);
      console.log(`  cam2: ${window.state.camPreset.cam2} / 번호: ${window.state.camNumbers.cam2no}`);
      
      // 마지막 액션 찾기
      let lastActionDesc = '';
      const streets = ['river', 'turn', 'flop', 'preflop'];
      for(const st of streets) {
        const actions = window.state.actionState[st];
        if(actions.length > 0) {
          const last = actions[actions.length - 1];
          lastActionDesc = `${last.player} ${last.action} ${last.amount || ''}`.trim();
          break;
        }
      }
      
      // 작업 상태 판단
      function determineWorkStatus() {
        // 승자가 선택되었으면 '완료'
        if(window.state.playersInHand.some(p => p.role === 'winner')) {
          return '완료';
        }
        // 리버까지 갔으면 '검토필요'
        if(window.state.currentStreet === 'river' && window.state.actionState.river.length > 0) {
          return '검토필요';
        }
        return '진행중';
      }
      
      // Index 시트의 전체 열 구조에 맞게 데이터 준비
      return {
        handNumber,                                           // A열
        // startRow, endRow는 서버에서 계산                    // B,C열
        handUpdatedAt,                                        // D열 (YYYY-MM-DD)
        // handEdit는 비워둠                                  // E열
        // handEditTime은 서버에서 처리                        // F열
        label: 'HOLDEM',                                      // G열
        table,                                                 // H열
        tableUpdatedAt: handUpdatedAt,                        // I열 (YYYY-MM-DD)
        cam: `${window.state.camPreset.cam1 || ''}+${window.state.camPreset.cam2 || ''}`, // J열
        camFile01name: window.state.camPreset.cam1 || '',            // K열
        camFile01number: getCamNumber('cam1'), // L열 - 자동 계산된 번호
        camFile02name: window.state.camPreset.cam2 || '',            // M열
        camFile02number: getCamNumber('cam2'), // N열 - 자동 계산된 번호
        lastStreet: window.state.currentStreet,                      // O열
        lastAction: lastActionDesc,                           // P열
        workStatus: determineWorkStatus()                     // Q열
      };
    }

    function buildTypeUpdates(){
      // 이번 핸드 동안 칩이 수정된 플레이어만 추려서 Type에 updatedAt 기록
      const table = window.state.selectedTable || '';
      return window.state.playersInHand
        .filter(p => p.chipsUpdatedAt) // 수정된 케이스만
        .map((p, index) => ({
          player: p.name,
          table,
          notable: p.notable || false, // Notable 정보 추가
          chips: String(p.chips || ''),
          updatedAt: p.chipsUpdatedAt, // ISO. 앱 스크립트에서 Date로 set
          seat: String(p.seat || index + 1) // Seat 정보 추가 (좌석 번호 또는 인덱스+1)
        }));
    }



    // ====== CAM PREFILL ======
    function computeCamPrefill(which){
      // 1) 자신의 값 있으면 그걸 표시
      if (which==='cam1' && window.state.camNumbers.cam1no) return pad4(window.state.camNumbers.cam1no);
      if (which==='cam2' && window.state.camNumbers.cam2no) return pad4(window.state.camNumbers.cam2no);

      // 2) 짝의 값 기반 자동 증가
      if (which==='cam2' && window.state.camNumbers.cam1no){
        return pad4((parseInt(window.state.camNumbers.cam1no,10)||0)+1);
      }
      if (which==='cam1' && window.state.camNumbers.cam2no){
        const v = (parseInt(window.state.camNumbers.cam2no,10)||0)-1;
        return pad4(v<0?0:v);
      }

      // 3) 마지막 입력(세션 기준) +1
      if (window.state.lastCamNo!=null){
        return pad4((parseInt(window.state.lastCamNo,10)||0)+1);
      }

      // 4) 기본값
      return '0001';
    }

    // 카메라 번호만 반환하는 함수 (패딩 없이)
    function getCamNumber(which) {
      // 1) 자신의 값 있으면 그걸 반환
      if (which === 'cam1' && window.state.camNumbers.cam1no) return window.state.camNumbers.cam1no;
      if (which === 'cam2' && window.state.camNumbers.cam2no) return window.state.camNumbers.cam2no;

      // 2) 짝의 값 기반 자동 증가
      if (which === 'cam2' && window.state.camNumbers.cam1no) {
        return String((parseInt(window.state.camNumbers.cam1no, 10) || 0) + 1);
      }
      if (which === 'cam1' && window.state.camNumbers.cam2no) {
        const v = (parseInt(window.state.camNumbers.cam2no, 10) || 0) - 1;
        return String(v < 0 ? 0 : v);  // 0보다 작으면 0으로
      }

      // 3) 마지막 입력(세션 기준) +1
      if (window.state.lastCamNo != null) {
        return String((parseInt(window.state.lastCamNo, 10) || 0) + 1);
      }

      // 4) 현재 표시된 카메라 값에서 패딩을 제거한 숫자값 반환
      // computeCamPrefill과 같은 로직이지만 순환참조를 피하기 위해 직접 구현
      if (which === 'cam1' && el.cam1) {
        const displayText = el.cam1.textContent || '';
        const match = displayText.match(/(\d+)$/); // 마지막 숫자들 추출
        if (match) {
          return String(parseInt(match[1], 10) || 0);
        }
      }
      if (which === 'cam2' && el.cam2) {
        const displayText = el.cam2.textContent || '';
        const match = displayText.match(/(\d+)$/); // 마지막 숫자들 추출
        if (match) {
          return String(parseInt(match[1], 10) || 0);
        }
      }

      // 5) 최종 기본값
      return '0';
    }


    // ====== SIDEPOT CALCULATION ======
    function calculateSidePots() {
      const contributions = {};
      
      // 각 스트리트별 플레이어 기여액 계산
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        window.state.actionState[street].forEach(action => {
          if(action.amount && action.player) {
            contributions[action.player] = (contributions[action.player] || 0) + 
                                          parseInt(unformatNumber(action.amount), 10);
          }
        });
      });
      
      // 올인 플레이어 정렬 (금액 오름차순)
      const allInPlayers = window.state.playersInHand
        .filter(p => window.state.playerStatus[p.name] === 'allin')
        .map(p => ({ name: p.name, amount: contributions[p.name] || 0 }))
        .sort((a, b) => a.amount - b.amount);
      
      const activePlayers = window.state.playersInHand
        .filter(p => window.state.playerStatus[p.name] !== 'folded')
        .map(p => p.name);
      
      const pots = [];
      let remainingPlayers = [...activePlayers];
      let previousCap = 0;
      
      // 각 올인 레벨별 팟 생성
      allInPlayers.forEach(allinPlayer => {
        const cap = allinPlayer.amount;
        const potPlayers = remainingPlayers.filter(p => contributions[p] >= cap);
        const potAmount = (cap - previousCap) * potPlayers.length;
        
        if(potAmount > 0) {
          pots.push({
            amount: potAmount,
            players: [...potPlayers],
            cap: cap,
            type: pots.length === 0 ? 'main' : `side${pots.length}`
          });
        }
        
        remainingPlayers = remainingPlayers.filter(p => p !== allinPlayer.name);
        previousCap = cap;
      });
      
      // 남은 베팅 (최고 베팅자들끼리)
      if(remainingPlayers.length > 0) {
        const maxBet = Math.max(...remainingPlayers.map(p => contributions[p] || 0));
        const finalPot = (maxBet - previousCap) * remainingPlayers.length;
        
        if(finalPot > 0) {
          pots.push({
            amount: finalPot,
            players: remainingPlayers,
            cap: maxBet,
            type: pots.length === 0 ? 'main' : `side${pots.length}`
          });
        }
      }
      
      return { pots, contributions };
    }
    
    // ====== RESET & FEEDBACK ======
    async function resetApp(reloadIndex = true, autoIncrement = false){
      let lastNo;
      
      if(autoIncrement) {
        // 시트 전송 직후: 현재 핸드 번호를 그대로 사용 (이미 전송된 번호)
        lastNo = parseInt(window.state.actionState.handNumber, 10) || 0;
        console.log('🔄 시트 전송 완료 - 다음 핸드로 자동 증가:', lastNo, '→', lastNo + 1);
      } else if(reloadIndex) {
        // 새로고침이나 수동 재설정: Index를 다시 로드하여 최신 핸드 번호 가져오기
        try {
          if(CSV_INDEX_URL.includes('http')){
            const idxRows = await fetchCsv(CSV_INDEX_URL + `&cb=${Date.now()}`);
            buildIndexFromCsv(idxRows);
          }
        } catch(err) {
          console.error('Index 재로드 실패:', err);
        }
        
        lastNo = window.state.indexRows.length
          ? Math.max(...window.state.indexRows.map(r=>parseInt(r.handNumber,10)||0))
          : 0;
        console.log('🔄 Index 재로드 - 마지막 핸드:', lastNo, '→ 다음:', lastNo + 1);
      } else {
        // Index 재로드 없이 현재 상태 유지
        lastNo = window.state.indexRows.length
          ? Math.max(...window.state.indexRows.map(r=>parseInt(r.handNumber,10)||0))
          : 0;
      }
      
      // 마지막 카메라 번호 저장 및 다음 번호 준비
      const lastCam1 = window.state.camNumbers.cam1no;
      const lastCam2 = window.state.camNumbers.cam2no;
      
      // 플레이어 유지하면서 새 핸드 시작
      console.log('🔄 새 핸드 시작 - 플레이어 초기화');
      
      // 기존 플레이어들의 현재 칩을 다음 핸드의 시작칩으로 설정
      window.state.playersInHand.forEach(p => {
        // 현재 칩을 시작칩으로 재설정
        p.initialChips = p.chips;
        p.hand = [];  // 핸드 카드 초기화
        p.role = null;  // 역할 초기화
        console.log(`  ${p.name}: 시작칩 = ${p.initialChips} (현재칩 유지)`);
      });
      
      window.state.board = [];
      window.state.playerStatus = {}; // 플레이어 상태 초기화
      window.state.currentStreet = 'preflop'; // 스트리트 초기화
      window.state.actionState = {
        handNumber: String(lastNo + 1),
        smallBlind: window.state.actionState.smallBlind,
        bigBlind: window.state.actionState.bigBlind,
        hasBBAnte: window.state.actionState.hasBBAnte,
        preflop: [], flop: [], turn: [], river: [],
      };
      
      // localStorage에서 마지막 카메라 번호 읽기
      const savedCam1 = localStorage.getItem('pokerHandLogger_lastCam1') || '';
      const savedCam2 = localStorage.getItem('pokerHandLogger_lastCam2') || '';
      
      console.log('📷 새 핸드 - 카메라 번호 자동 증가:');
      console.log(`  localStorage cam1: ${savedCam1 || '없음'}`);
      console.log(`  localStorage cam2: ${savedCam2 || '없음'}`);
      console.log(`  현재 cam1: ${lastCam1 || '없음'}`);
      console.log(`  현재 cam2: ${lastCam2 || '없음'}`);
      
      // 카메라 번호 자동 증가
      // cam1 처리: 저장된 번호 또는 현재 번호에서 +1
      const cam1Base = savedCam1 || lastCam1 || '0';
      const currentNum1 = parseInt(cam1Base, 10) || 0;
      const nextCam1 = currentNum1 > 0 ? currentNum1 + 1 : 1;
      window.state.camNumbers.cam1no = String(nextCam1);
      window.state.lastCamNo = String(nextCam1);
      el.cam1.textContent = `${window.state.camPreset.cam1}${pad4(nextCam1)}`;
      localStorage.setItem('pokerHandLogger_lastCam1', String(nextCam1));
      console.log(`  → ${window.state.camPreset.cam1} 다음 번호: ${nextCam1}`);
      
      // cam2 처리: 저장된 번호 또는 현재 번호에서 +1
      const cam2Base = savedCam2 || lastCam2 || '0';
      const currentNum2 = parseInt(cam2Base, 10) || 0;
      const nextCam2 = currentNum2 > 0 ? currentNum2 + 1 : 1;
      window.state.camNumbers.cam2no = String(nextCam2);
      window.state.lastCamNo = String(nextCam2);
      el.cam2.textContent = `${window.state.camPreset.cam2}${pad4(nextCam2)}`;
      localStorage.setItem('pokerHandLogger_lastCam2', String(nextCam2));
      console.log(`  → ${window.state.camPreset.cam2} 다음 번호: ${nextCam2}`);
      
      renderAll(); saveActionState();
      el.handNumberDisplay.textContent = `#${window.state.actionState.handNumber}`;
    }
    function showFeedback(msg,isErr=false){
      el.feedbackMessage.textContent = msg;
      el.feedbackMessage.className = `text-center h-4 text-xs font-semibold ${isErr?'text-red-400':'text-green-400'}`;
    }

    // ====== EVENT LISTENERS ======
    function setupEventListeners(){
      el.loadHandBtn.onclick = openLoadHandModal;
      el.refreshDataBtn.onclick = loadInitial;
      el.resetBtn.onclick = resetApp;
      
      // Cam 버튼 클릭 - 바로 키패드 열기
      el.cam1.addEventListener('click', ()=>{
        const prefill = computeCamPrefill('cam1');
        openKeypad(null, { purpose:'cam', cam:'cam1', prefill });
      });

      el.cam2.addEventListener('click', ()=>{
        const prefill = computeCamPrefill('cam2');
        openKeypad(null, { purpose:'cam', cam:'cam2', prefill });
      });
      // "시트 전송" 버튼을 누르면 → 바로 전송 (노트 기능 제거)
      el.sendToSheetBtn.onclick = () => { sendDataToGoogleSheet(); };
      
      // 노트 모달 관련 이벤트 제거 (노트 기능 삭제)
      
      el.showLogBtn.onclick = openLogModal;
      el.closeLogModalBtn.onclick = closeLogModal;
      
      // 로그 모달 배경 클릭 시 닫기
      el.logModal.addEventListener('click', (e)=>{
        if(e.target === el.logModal) {
          closeLogModal();
        }
      });

      // 테이블 선택 버튼 및 모달 이벤트
      el.tableSelectorBtn.onclick = openTableSelectorModal;
      document.getElementById('close-table-selector').onclick = closeTableSelectorModal;
      
      // 테이블 모달 검색 및 필터
      document.getElementById('table-search').oninput = (e) => {
        tableModalState.searchTerm = e.target.value;
        tableModalState.currentPage = 1;
        renderTableGrid();
      };
      
      // 필터 버튼들
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.onclick = () => {
          // 모든 필터 버튼 비활성화
          document.querySelectorAll('.filter-btn').forEach(b => {
            b.classList.remove('bg-blue-600', 'text-white');
            b.classList.add('bg-gray-600', 'hover:bg-gray-500');
          });
          // 클릭된 버튼 활성화
          btn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
          btn.classList.add('bg-blue-600', 'text-white');
          
          tableModalState.currentFilter = btn.id.replace('filter-', '');
          tableModalState.currentPage = 1;
          renderTableGrid();
        };
      });
      
      // 페이지 네비게이션
      document.getElementById('prev-page').onclick = () => {
        if (tableModalState.currentPage > 1) {
          tableModalState.currentPage--;
          renderTableGrid();
        }
      };
      
      document.getElementById('next-page').onclick = () => {
        const filteredTables = getFilteredTables();
        const totalPages = Math.ceil(filteredTables.length / tableModalState.tablesPerPage);
        if (tableModalState.currentPage < totalPages) {
          tableModalState.currentPage++;
          renderTableGrid();
        }
      };
      
      // 모달 외부 클릭시 닫기
      el.tableSelectorModal.onclick = (e) => {
        if (e.target === el.tableSelectorModal) {
          closeTableSelectorModal();
        }
      };
      el.timezoneSelector.onchange = (e)=>{ window.state.selectedTimezone=e.target.value; updateTimeDisplay(); renderAll(); };
      
      // Smart Mode 토글
      document.getElementById('smart-mode-toggle').onchange = (e) => {
        window.state.smartCheckCall = e.target.checked;
        showFeedback(window.state.smartCheckCall ? 'Smart Mode 활성화' : 'Smart Mode 비활성화');
      };

      // 플레이어 선택/해제
      el.playerSelectionButtons.addEventListener('click', (e)=>{
        const btn = e.target.closest('button'); if(!btn) return;
        const name = btn.dataset.playerName; if(!name) return;
        togglePlayerInHand(name);
      });

      // 플레이어 카드/칩 입력
      el.playerDetailsSection.addEventListener('click', (e)=>{
        const cardPlaceholder = e.target.closest('.card-placeholder');
        const keypadBtn = e.target.closest('.keypad-icon-btn');
        const playerCard = e.target.closest('.player-card');
        if(!playerCard) return;
        if(cardPlaceholder){
          window.state.modalState.cardTarget = { target:'playerHand', player:cardPlaceholder.dataset.playerName, count:parseInt(cardPlaceholder.dataset.count) };
          openCardSelector();
        }else if(keypadBtn){
          const input = playerCard.querySelector('.player-chip-input');
          openKeypad(input, { purpose:'input' });
        }
      });

      // 승자 토글
      el.winnerButtons.addEventListener('click', (e)=>{
        const btn=e.target.closest('.set-winner-btn'); if(!btn) return;
        setPlayerRole(btn.dataset.playerName);
      });

      // 칩 입력 포맷팅
      el.playerDetailsSection.addEventListener('input', (e)=>{
        if(!e.target.classList.contains('player-chip-input')) return;
        const parent = e.target.closest('.player-card');
        const player = window.state.playersInHand.find(p=>p.name===parent.dataset.playerName);
        const raw = unformatNumber(e.target.value);
        e.target.value = formatNumber(raw);
        
        if (player){
          const oldChips = player.chips;
          player.chips = raw;
          player.chipsUpdatedAt = new Date().toISOString();
          
          // initialChips가 아직 설정되지 않았거나 핸드 시작 전이면 initialChips도 업데이트
          if(!player.initialChips || player.initialChips === '' || player.initialChips === '0') {
            player.initialChips = raw;
            console.log(`🎰 ${player.name}의 시작칩 설정: ${raw}`);
          } else {
            console.log(`💰 ${player.name}의 칩 변경: ${oldChips} → ${raw} (시작칩 유지: ${player.initialChips})`);
          }
        }
      });

      // 보드 카드 선택
      el.boardCardPlaceholders.addEventListener('click', (e)=>{
        const ph = e.target.closest('.card-placeholder'); if(!ph) return;
        window.state.modalState.cardTarget = { target:'board', index:parseInt(ph.dataset.index), count:parseInt(ph.dataset.count) };
        openCardSelector();
      });

      // 카드 선택 모달 이벤트
      el.cardSelectorModal.addEventListener('click', (e)=>{
        // 모달 배경 클릭 시 닫기
        if(e.target === el.cardSelectorModal) {
          closeModal(el.cardSelectorModal);
          return;
        }
        // 닫기 버튼 클릭
        if(e.target.id==='close-card-modal') closeModal(el.cardSelectorModal);
      });

      // 스트리트 버튼(추가/되돌리기/Pot 교정/스트리트 선택)
      el.streetLogsContainer.addEventListener('click', (e)=>{
        const streetBtn = e.target.closest('.street-select-btn');
        const addBtn = e.target.closest('.add-action-btn');
        const undoBtn = e.target.closest('.undo-action-btn');
        const potBtn = e.target.closest('.pot-keypad-btn');
        
        if(streetBtn) {
          window.state.currentStreet = streetBtn.dataset.street;
          renderActionStreets(); // 하이라이트 업데이트
        }
        if(addBtn) openActionPad(addBtn.dataset.street);
        if(undoBtn) undoLastAction(undoBtn.dataset.street);
        if(potBtn){
          window.state.modalState.actionPadStreet = potBtn.dataset.street;
          openKeypad(null, { purpose:'pot', currentPot: potBtn.dataset.currentPot });
        }
      });

      // 액션 패드 내부 버튼
      el.actionPadModal.addEventListener('click', (e)=>{
        // 모달 배경 클릭 시 닫기
        if(e.target === el.actionPadModal) {
          closeModal(el.actionPadModal);
          return;
        }
        
        const btn = e.target.closest('button'); if(!btn) return;
        if(btn.id==='close-action-pad'){ closeModal(el.actionPadModal); return; }
        const modal = el.actionPadModal;
        if(btn.parentElement.id==='action-pad-players'){
          window.state.modalState.actionPadPlayer = btn.dataset.playerName;
          modal.querySelector('#action-pad-players').classList.add('hidden');
          modal.querySelector('#action-pad-actions').classList.remove('hidden');
          
          // 스마트 Check/Call 버튼 업데이트
          if(window.state.smartCheckCall) {
            const smartBtn = modal.querySelector('#smart-check-call-btn');
            const smartAction = getSmartCheckCallAction(btn.dataset.playerName, window.state.modalState.actionPadStreet);
            smartBtn.querySelector('.action-label').textContent = smartAction.label;
            smartBtn.dataset.smartAction = JSON.stringify(smartAction);
          }
        }else if(btn.parentElement.id==='action-pad-actions'){
          const action = btn.dataset.action;
          if(action==='Bet/Raises'){
            const st = window.state.modalState.actionPadStreet;
            const hasBet = window.state.actionState[st].some(a=>/BET|RAISE/i.test(a.action||''));
            window.state.modalState.actionPadCurrentAction = hasBet ? 'Raises' : 'Bets';
            closeModal(el.actionPadModal); openKeypad(null, { purpose:'bet' });
          }else if(action==='SmartCheckCall'){
            // 스마트 Check/Call 처리
            const smartBtn = btn;
            const smartAction = JSON.parse(smartBtn.dataset.smartAction || '{}');
            if(smartAction.action) {
              addActionToLog(smartAction.action, smartAction.amount);
            }
          }else if(action==='All In'){
            const p = window.state.playersInHand.find(pp=>pp.name===window.state.modalState.actionPadPlayer);
            if(p) addActionToLog('All In', p.chips);
          }else if(action==='Calls'){
            const st = window.state.modalState.actionPadStreet;
            const p = window.state.playersInHand.find(pp=>pp.name===window.state.modalState.actionPadPlayer);
            
            // 현재 스트리트와 이전 스트리트에서 마지막 베팅/레이즈 찾기
            let lastBet = null;
            let requiredAmt = 0;
            
            // 현재 스트리트에서 찾기
            lastBet = [...window.state.actionState[st]].reverse().find(a=>/BET|RAISE|All In/i.test(a.action||''));
            
            if(!lastBet && st !== 'preflop') {
              // 현재 스트리트에 베팅이 없으면 이전 스트리트 확인
              const streetOrder = ['preflop', 'flop', 'turn', 'river'];
              const currentIdx = streetOrder.indexOf(st);
              for(let i = currentIdx - 1; i >= 0; i--) {
                lastBet = [...window.state.actionState[streetOrder[i]]].reverse().find(a=>/BET|RAISE|All In/i.test(a.action||''));
                if(lastBet) break;
              }
            }
            
            // 콜 금액 결정
            if(lastBet) {
              requiredAmt = lastBet.amount;
            } else if(st === 'preflop') {
              // 프리플랍에서 아무도 베팅하지 않았으면 빅블라인드 콜
              requiredAmt = unformatNumber(window.state.actionState.bigBlind);
            } else {
              // 포스트플랍에서 베팅이 없으면 체크해야 함
              showFeedback('베팅이 없어 체크를 선택해주세요', true);
              return;
            }
            
            // 플레이어 현재 칩
            const playerChips = p ? parseInt(unformatNumber(p.chips), 10) : 0;
            
            // 올인 콜 체크: 필요 금액이 플레이어 칩보다 크면 올인
            if(playerChips > 0 && playerChips <= parseInt(unformatNumber(requiredAmt), 10)){
              // 올인 콜 (플레이어의 모든 칩)
              addActionToLog('All In', p.chips);
            } else {
              // 일반 콜
              addActionToLog('Calls', requiredAmt);
            }
          }else{
            addActionToLog(action);
          }
        }
      });

      // 바깥쪽 키패드 버튼(SB/BB 등)
      document.body.addEventListener('click', (e)=>{
        const kb = e.target.closest('.keypad-icon-btn');
        if(kb && !kb.closest('.player-card')) openKeypad(kb.previousElementSibling, { purpose:'input' });
      });

      // 키패드 입력
      el.keypadModal.addEventListener('click', (e)=>{
        // 모달 배경 클릭 시 닫기
        if(e.target === el.keypadModal) {
          closeModal(el.keypadModal);
          return;
        }
        
        const btn = e.target.closest('button'); if(!btn) return;
        const display = el.keypadModal.querySelector('#keypad-display');
        const key = btn.textContent;
        if(btn.id==='keypad-confirm'){
          const finalAmt = unformatNumber(display.textContent);
          const { purpose, currentPot } = window.state.modalState.keypadOptions;
          if(purpose==='cam'){
            const which = window.state.modalState.keypadOptions.cam; // 'cam1'|'cam2'
            const padded = pad4(finalAmt);
            const numValue = String(finalAmt); // 숫자만 저장 (0007 → 7)
            if (which==='cam1'){
              window.state.camNumbers.cam1no = numValue; // 숫자로 저장
              window.state.lastCamNo = numValue;
              el.cam1.textContent = `${window.state.camPreset.cam1}${padded}`; // 표시는 패딩된 형태로
              localStorage.setItem('pokerHandLogger_lastCam1', numValue); // localStorage에 숫자로 저장
              showFeedback(`${window.state.camPreset.cam1 || 'Cam1'}${padded} 입력됨`);
              console.log(`📷 cam1 저장: ${window.state.camPreset.cam1}=${numValue}`);
            }else if (which==='cam2'){
              window.state.camNumbers.cam2no = numValue; // 숫자로 저장
              window.state.lastCamNo = numValue;
              el.cam2.textContent = `${window.state.camPreset.cam2}${padded}`; // 표시는 패딩된 형태로
              localStorage.setItem('pokerHandLogger_lastCam2', numValue); // localStorage에 숫자로 저장
              console.log(`📷 cam2 저장: ${window.state.camPreset.cam2}=${numValue}`);
              showFeedback(`${window.state.camPreset.cam2 || 'Cam2'}${padded} 입력됨`);
            }
          }else if(purpose==='bet'){
            if(finalAmt) addActionToLog(window.state.modalState.actionPadCurrentAction, finalAmt);
          }else if(purpose==='pot'){
            // Pot correction: 입력한 값 그대로 저장 (이전 팟 크기를 빼지 않음)
            const potSize = finalAmt; // 포맷된 값 그대로 사용
            if(potSize){
              const st = window.state.modalState.actionPadStreet;
              // Pot Correction은 player 없이 저장 (시스템 액션)
              window.state.actionState[st].push({ 
                action:'Pot Correction', 
                amount:potSize,  // 포맷된 값 그대로 저장
                timestamp:new Date().toISOString() 
              });
              saveActionState(); renderAll();
            }
          }else if(purpose==='input'){
            if(window.state.modalState.keypadTarget){
              window.state.modalState.keypadTarget.value = display.textContent;
              window.state.modalState.keypadTarget.dispatchEvent(new Event('input',{bubbles:true}));
            }
          }
          closeModal(el.keypadModal);
        }else if(btn.id==='keypad-cancel'){ closeModal(el.keypadModal);
        }else if(key==='C'){ display.textContent='';
        }else if(key==='←'){ display.textContent = formatNumber(unformatNumber(display.textContent).slice(0,-1));
        }else{
          display.textContent = formatNumber(unformatNumber(display.textContent) + key);
        }
      });

      // SB/BB/Ante 체크
      document.querySelectorAll('.number-input').forEach(inp=>{
        inp.addEventListener('input', (e)=>{
          const raw = unformatNumber(e.target.value);
          const fmt = formatNumber(raw);
          if(e.target.value!==fmt) e.target.value=fmt;
          const k = toCamelCase(e.target.id.replace('-input','')); // small-blind-input -> smallBlind
          if(k in window.state.actionState) window.state.actionState[k]=raw;
          saveActionState();
        });
      });
      el.bbAnteCheckbox.onchange = (e)=>{ window.state.actionState.hasBBAnte = e.target.checked; saveActionState(); renderAll(); };

      // Load Hand 모달 내부 클릭
      el.loadHandModal.addEventListener('click', (e)=>{
        // 핸드 항목 클릭 우선 처리
        const itemBtn = e.target.closest('.load-hand-item-btn');
        if(itemBtn){
          const no = itemBtn.dataset.no;
          const dt = itemBtn.dataset.date || null;
          loadHandData(no, dt);
          return;
        }
        
        // 닫기 버튼 클릭
        const closeBtn = e.target.closest('#close-load-hand-modal');
        if(closeBtn) {
          closeModal(el.loadHandModal);
          return;
        }
        
        // 모달 컨텐츠 영역 클릭은 무시
        const content = e.target.closest('.bg-gray-800');
        if(content) return;
        
        // 모달 배경 클릭 시 닫기
        if (e.target === el.loadHandModal) {
          closeModal(el.loadHandModal);
        }
      });
    }

    // ====== 관리 모달 관련 함수 ======
    function openRegistrationModal() {
      const modal = el.registrationModal;
      if (modal) {
        modal.classList.remove('hidden');
        setTimeout(() => modal.classList.remove('opacity-0'), 10);
      }
    }
    
    function closeRegistrationModal() {
      const modal = el.registrationModal;
      if (modal) {
        modal.classList.add('opacity-0');
        setTimeout(() => modal.classList.add('hidden'), 300);
      }
    }
    
    // 탭 전환 함수
    function switchTab(tabName) {
      // 모든 탭 콘텐츠 숨기기
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.add('hidden');
      });
      
      // 모든 탭 버튼 스타일 초기화
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('bg-amber-600');
        btn.classList.add('bg-gray-600', 'hover:bg-gray-500');
      });
      
      // 선택한 탭 활성화
      const selectedContent = document.getElementById(`tab-content-${tabName}`);
      const selectedBtn = document.getElementById(`tab-${tabName}`);
      
      if (selectedContent) {
        selectedContent.classList.remove('hidden');
      }
      
      if (selectedBtn) {
        selectedBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
        selectedBtn.classList.add('bg-amber-600');
      }
    }
    
    // 관리 모달 이벤트 리스너 - 테이블 관리 모듈로 변경
    if (el.managePlayersBtn) {
      el.managePlayersBtn.addEventListener('click', () => {
        if (typeof openTableManagement === 'function') {
          openTableManagement(); // 새로운 테이블 관리 시스템
        } else {
          openRegistrationModal(); // 기존 시스템 폴백
        }
      });
    }
    
    const closeBtn = document.getElementById('close-registration-modal');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeRegistrationModal);
    }
    
    // 탭 버튼 이벤트 리스너
    document.getElementById('tab-players')?.addEventListener('click', () => switchTab('players'));
    document.getElementById('tab-chips')?.addEventListener('click', () => switchTab('chips'));

    // ====== INIT ======
    async function initializeApp(){
      el.logDisplay.innerHTML=''; 
      openLogModal(); 
      logMessage(`🎯 ${VERSION_INFO}`);
      logMessage(`📅 초기화 시작: ${new Date().toLocaleString('ko-KR')}`);
      populateTimezones(); loadActionState();
      try{
        await loadInitial();
        renderTableSelection();
        if(timeUpdater) clearInterval(timeUpdater);
        timeUpdater = setInterval(updateTimeDisplay, 1000);
        updateTimeDisplay();
        logMessage(`✅ ${APP_VERSION} 준비 완료!`);
      }catch(err){
        console.error(err); logMessage(`초기화 실패: ${err.message}`, true);
      }finally{
        setTimeout(closeLogModal, 800);
      }
    }

    setupEventListeners();
    initializeApp();
  });
  </script>
</body>
</html>
